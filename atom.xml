<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oxyethylene&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-13T13:55:14.357Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>氧乙烯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++笔记: 类 (一)</title>
    <link href="http://example.com/2021/10/11/C-%E7%AC%94%E8%AE%B0-%E7%B1%BB-%E4%B8%80/"/>
    <id>http://example.com/2021/10/11/C-%E7%AC%94%E8%AE%B0-%E7%B1%BB-%E4%B8%80/</id>
    <published>2021-10-11T10:38:36.000Z</published>
    <updated>2021-10-13T13:55:14.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    C++是笔者这学期最重要的专业课之一。目前上课内容已简单介绍完C++的类的相关知识。</p><p>​    但是由于老师上课时的解析<del>经常听不懂</del>比较有深度，目前我对于C++类的认识还比较浅显，所以打算再花点时间自学并整理一遍相关内容。</p><p>​    <span id="more"></span></p><h2 id="类的声明及定义"><a href="#类的声明及定义" class="headerlink" title="类的声明及定义"></a>类的声明及定义</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    类即类型的简称，用于描述对象的共同属性和方法。在C++中，类可以使用 <code>struct</code> 、<code>class</code> 或者 <code>union</code> 来定义。其中，类的属性用数据成员表示，类的方法用函数成员来表示。类的成员可以使用保留字 <code>private</code> 、<code>public</code> 或者 <code>protected</code> 来标识访问权限。</p><p>​    对象是类的实例，也就是某个类的值，它可以是一个变量，也可以是一个常量。类是一种__数据结构__，而对象代表了一段__内存__，存储了数据结构的值。当产生一个对象时，必须调用__构造函数__初始化对象；当一个对象“死亡”时，则需要调用__析构函数__释放对象占用的资源。</p><h3 id="关于访问控制"><a href="#关于访问控制" class="headerlink" title="关于访问控制"></a>关于访问控制</h3><p>​    关键字<code>private</code> 、<code>public</code> 和 <code>protected</code>描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但<u>只能通过公有成员函数 (或者友元函数) 来访问对象的私有成员</u>。</p><p>​    <code>private</code> 成员仅供<strong>同一类</strong>的成员函数访问；<code>protected</code> 成员仅供所在类及派生类的成员函数访问；<code>public</code> 成员可供任何成员或非成员函数访问。</p><p>​    无论类的数据成员还是成员函数，都可以在类的公有部分或者私有部分中声明它。通常把数据成员放在私有部分，组成类接口的成员函数放在公有部分。</p><p>​    不必在<strong>class类</strong>声明中使用关键字 <code>private</code> ，因为这是它的默认访问控制(注：struct和union定义的类成员默认访问权限为 <code>public</code>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">world</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> mass;<span class="comment">//默认是私有的</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>]<span class="comment">//私有</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>​    构造函数是类封装的特殊的实例函数成员，用于对对象的数据成员进行初始化，<u>对象必须初始化且仅能初始化一次</u>。 <strong>默认构造函数</strong>不能被显式调用。 </p><p>​    构造函数为对象申请各种资源用于初始化。除了隐含参数 <code>this</code> 外，构造函数还可以自带若干参数。</p><p>​    构造函数与类名同名。</p><p>​    <strong>需要注意的是</strong>，如果没有提供任何构造函数，则C++会自动提供<strong>默认构造函数</strong>，它不会做任何工作。对于某个类，如Stock类，默认构造函数可能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>() &#123;...&#125;<span class="comment">//参数表无参</span></span><br></pre></td></tr></table></figure><p>​    并且，<strong>当且仅当</strong>没有定义任何构造函数时，编译器才会提供默认构造函数。也就是说，为类定义了构造函数之后，程序员还必须为类提供默认构造函数。如果在定义前者之后未定义后者，以下声明将出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock stock1;</span><br></pre></td></tr></table></figure><p>​    通常用户定义的默认构造函数应可以给给所有成员提供隐式初始值。</p><p>​    构造函数既可以用于类的初始化，也可以用来给类赋新值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock stock2 = <span class="built_in">Stock</span>(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>);<span class="comment">//这里是初始化，可能会创建新的临时对象（看编译器）用于赋值</span></span><br><span class="line">stock1 = <span class="built_in">Stock</span>(<span class="string">&quot;Niftty Foods&quot;</span>, <span class="number">10</span>, <span class="number">50.0</span>);<span class="comment">//这里是赋值而不是初始化，实际上创建了一个新的对象，然后将其内容复制给stock1</span></span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>​    析构函数也是类封装的特殊的实例函数成员，其特点是和类名同名且名前带有<strong>“ ~ ”</strong>，同时，无论是程序自定义还是C++默认生成的析构函数，都只能有一个隐含参数 <code>this</code> 。  析构函数可以被显式调用。</p><p>​    析构函数用于对数据成员申请的资源进行回收，如果构造函数为类成员动态分配了内存（如<strong>new</strong>），则析构函数相应地要释放这些内存（<strong>delete</strong>）。与构造函数不同，析构函数可以执行多次，但是应当尽量避免资源被多次释放。</p><p>​    构造函数和析构函数都不可以定义返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STRING</span>//定义了一个名为<span class="title">STRING</span>的类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span>* CHARPTR;<span class="comment">//定义类型成员</span></span><br><span class="line">    CHARPTR s;<span class="comment">//定义数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">()</span></span>;<span class="comment">//定义函数成员</span></span><br><span class="line">    <span class="built_in">STRING</span>(<span class="keyword">const</span> <span class="keyword">char</span>*);<span class="comment">//定义构造函数</span></span><br><span class="line">    ~<span class="built_in">STRING</span>();<span class="comment">//定义析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">STRING <span class="title">y</span><span class="params">(<span class="string">&quot;complex&quot;</span>)</span></span>;<span class="comment">//自动调用构造函数STRING(&quot;complex&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-11-列表初始化"><a href="#C-11-列表初始化" class="headerlink" title="C++11 列表初始化"></a>C++11 列表初始化</h3><p>​    在<strong>C++11</strong>中，可以将列表初始化语法应用于类，只要提供与某个构造函数的参数列表匹配的内容即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock hot_tip = &#123;<span class="string">&quot;...&quot;</span>, <span class="number">100</span>, <span class="number">45.0</span>&#125;;<span class="comment">//可与构造函数Stock(const string &amp;co, long n = 0, double pr = 0.0)匹配</span></span><br><span class="line">Stock temp = &#123;&#125;;<span class="comment">//可与无参的默认构造函数Stock()匹配</span></span><br></pre></td></tr></table></figure><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Stock land = <span class="built_in">Stock</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">land.<span class="built_in">show</span>();<span class="comment">//假设show()是Stock的成员函数</span></span><br></pre></td></tr></table></figure><p>​    假如有如上代码片段，对于当前的C++，编译器会拒绝第二行。因为show()的代码可能不能保证调用对象不被修改——调用对象就跟const一样不应被修改。对于没有任何参数的成员函数，我们并不能通过将函数参数声明为const引用或指向const的指针来解决问题。这里的解决方法是将const关键字加到函数的括号后面，即相关函数的定义和声明应如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//保证函数不修改对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>​    以这种方式声明和定义的类函数被称为<strong>const成员函数</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    C++是笔者这学期最重要的专业课之一。目前上课内容已简单介绍完C++的类的相关知识。&lt;/p&gt;
&lt;p&gt;​    但是由于老师上课时的解析&lt;del&gt;经常听不懂&lt;/del&gt;比较有深度，目前我对于C++类的认识还比较浅显，所以打算再花点时间自学并整理一遍相关内容。&lt;/p&gt;
&lt;p&gt;​</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
</feed>
