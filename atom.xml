<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oxyethylene&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-26T15:43:49.500Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>氧乙烯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人文摄影中如何拍摄陌生人</title>
    <link href="http://example.com/2021/11/26/%E4%BA%BA%E6%96%87%E6%91%84%E5%BD%B1%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8B%8D%E6%91%84%E9%99%8C%E7%94%9F%E4%BA%BA/"/>
    <id>http://example.com/2021/11/26/%E4%BA%BA%E6%96%87%E6%91%84%E5%BD%B1%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8B%8D%E6%91%84%E9%99%8C%E7%94%9F%E4%BA%BA/</id>
    <published>2021-11-26T15:32:12.000Z</published>
    <updated>2021-11-26T15:43:49.500Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://imgtu.com/i/oZsYVA"><img src="https://z3.ax1x.com/2021/11/26/oZsYVA.jpg" alt="oZsYVA.jpg"></a></p><p>人文摄影每个人的定义都不同，我觉得本质就是关注人的生活状态的摄影活动。通常人文照片当中除了人（主体）以外，还会有背景、线条、符号等引出照片的故事（氛围），这五点称为照片的五要素。这里就不展开了 ，只简单介绍下我自己拍摄人文照片的三个拍摄陌生人的方法和拍摄方法。</p><p>陌生人的人像照（指还是能交待环境，不是过度虚化的人文类人像照）与人文照有相同点，也有很大的不同点，先对比下人像照片和人文照片有什么区别。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://imgtu.com/i/oZsYVA&quot;&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/11/26/oZsYVA.jpg&quot; alt=&quot;oZsYVA.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;人文摄影每个人的定义都不同，我觉得本</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>伪产品设计报告</title>
    <link href="http://example.com/2021/11/17/%E4%BC%AA%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
    <id>http://example.com/2021/11/17/%E4%BC%AA%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/</id>
    <published>2021-11-17T12:25:37.136Z</published>
    <updated>2021-11-17T12:35:40.601Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这周六自己选的公选课《产品的商业逻辑》就结课了，作为结课作业，我们需要完成一篇产品设计报告(内容不限，产品形态不限)。</p><p>最后是选择了设计一台手机了事(<del>其实还没写完也没有画概念图</del>)，在此感谢数码产品带佬 <strong>@寞落的风</strong> 提供的帮助以及建议。</p><p>细节之处可能不太符合逻辑，如有雷同，不胜荣幸。</p><span id="more"></span><h2 align = "center"> Penta Q 智能手机设计稿 </h2><h4 id="用户需求分析"><a href="#用户需求分析" class="headerlink" title="用户需求分析"></a>用户需求分析</h4><h5 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h5><p>在当今手机市场上的主流手机大多追求搭配大屏幕、优秀的拍照性能以及强大的处理器性能，不过，在这个时代，同样有着与之相对的一部分消费者：他们追求轻薄、小屏、外观时尚且握持感舒适的手机。当前市场上缺少这样类型的手机。</p><h5 id="需求特点"><a href="#需求特点" class="headerlink" title="需求特点"></a>需求特点</h5><ol><li><p>对手机三围、重量极度敏感，追求<strong>180g</strong>以下的机身重量以及<strong>8mm</strong>以下的机身厚度；同时，并不太在意因为缩减机身体积带来的电池容量减少、性能下降、散热变差的负面影响；</p></li><li><p>对手机的<strong>外观CMF</strong>、<strong>品牌效应</strong>比较看重，比起手机本身的功能价值，更在意手机的外在颜值以及面子问题；</p></li><li><p>手机价格对此类用户具有两面性：当手机价格区间<strong>1500 ~ 2500</strong>之间的时候，他们不会在意手机的具体价格；当手机超过<strong>3000</strong>元人民币的时候，由于高价格区间段具有上位竞品(如苹果数字系列)，此类手机对于他们的吸引力会逐步下降。</p></li></ol><h5 id="目标市场选择"><a href="#目标市场选择" class="headerlink" title="目标市场选择"></a>目标市场选择</h5><p>针对一二三线城市以及下级城镇的、平时一般不会选择在网上进行购机的年轻用户市场。</p><h4 id="产品开发"><a href="#产品开发" class="headerlink" title="产品开发"></a>产品开发</h4><h5 id="产品属性"><a href="#产品属性" class="headerlink" title="产品属性"></a>产品属性</h5><ol><li><p><strong>核心规格</strong></p><p><strong>中央处理器选择</strong>：联发科技<strong>mediatek  Dimensity 920 5G</strong> 移动处理器；</p><p><strong>内存&amp;存储搭配</strong>：<strong>8 + 128 / 8 + 256 GB</strong> ，内存规格为<strong>LPDDR 4X</strong> @ 2133 Mhz，闪存规格为 <strong>UFS 2.2</strong> ;</p></li><li><p><strong>外围配置</strong></p><p><strong>屏幕显示</strong>：6.2英寸 2340 * 1080分辨率<strong>AMOLED</strong> 10亿色显示屏，<strong>DCI-P3广色域</strong>，支持<strong>HDR 10</strong>，<strong>120Hz</strong>刷新率，180Hz触控采样率；</p><p><strong>充电</strong>：<strong>66W智慧超级闪充</strong>(不支持无线充电) &amp; 4000mah 1C电池；</p><p><strong>影像规格</strong>：前置<strong>3200W柔光美颜自拍</strong>，后置<strong>10800W</strong>(wide) + 800W(ultrawide) + 500W(micro) + 200W(depth)<strong>超感光全场景AI矩阵影像系统</strong></p><p>支持<strong>AIS智慧防抖</strong>，最高支持<strong>4K 30Fps超清录制</strong>；</p><p><strong>音响</strong>：立体声双扬声器，<strong>双Hi-Res认证</strong></p><p><strong>其它</strong>：<strong>电竞级八维立体钢化液冷散热结构</strong>、NFC、纳米镀层防水、<strong>超感屏下指纹5.0</strong>、4D震感线性马达</p></li><li><p><strong>外观参数</strong>(实验室测量数据)</p><p><strong>机身三围</strong>：154.2 * 70.1 * 7.6 mm</p><p><strong>重量</strong>：168g</p><p><strong>机身材质</strong>：中框为铝合金复合材质，后盖为AG磨砂材质/亮面玻璃</p><p><strong>SKU</strong>：黑色、白色(亮面)；蓝色、粉色、绿色(磨砂)</p></li><li><p>系统</p><p><strong>华为智选12</strong>系统(又名EMUI 12，基于Android 11，兼容homo OS 2.0)，36个月内不卡顿，支持2年内OTA系统&amp;安全更新。</p></li></ol><h5 id="产品如何满足用户需求"><a href="#产品如何满足用户需求" class="headerlink" title="产品如何满足用户需求"></a>产品如何满足用户需求</h5><ol><li><p>本产品为<strong>华为智选产品</strong>，具有<strong>华为官方认证资格</strong>，某种程度上属于华为产品序列，用户放心购买；</p></li><li><p>产品从<strong>外观</strong>、<strong>尺寸</strong>及<strong>重量</strong>方面基本满足了这部分用户的需求，同时没有彻底抛弃高性能，选择了主流芯片厂商目前主推的<strong>中高端性能芯片</strong>，同时<strong>超级快充</strong>以及<strong>低功耗处理器</strong>也能弥补5G时代下手机电池容量偏小带来的续航问题；</p></li><li><p>本产品在所属价位段具有很强的竞争力，且品牌效应明显，因此也可以吸引其他线下消费者的购买欲望。</p></li></ol><h4 id="竞品分析"><a href="#竞品分析" class="headerlink" title="竞品分析"></a>竞品分析</h4><p>竞品主要对象：友商<strong>S10e</strong>，友商<strong>reno 6</strong>， 友商 <strong>note 11 pro+</strong></p><table><thead><tr><th>对比方向</th><th>Penta Q</th><th>Reno 6</th><th>S10e</th><th>n11 pp</th></tr></thead><tbody><tr><td>核心处理器</td><td><font color="red">天玑920</font></td><td><font color="green">天玑900</font></td><td><font color="red">天玑920</font></td><td><font color="red">天玑920</font></td></tr><tr><td>屏幕</td><td><font color="red">120Hz 10亿色 </font></td><td>90Hz</td><td><font color="green">60Hz 水滴屏</font></td><td>120Hz</td></tr><tr><td>拍照</td><td>前置3200w 后置<font color="red">10800w+800w+500w+200w</font></td><td>前置3200w 后置6400w+800w+200w</td><td>前置3200w 后置6400w+800w+200w</td><td><font color="green">前置1600w </font>后置10800w+800w+200w</td></tr><tr><td>机身材质</td><td>复合铝合金中框+玻璃背板</td><td>磨砂铝合金中框+玻璃背板</td><td>塑料中框+玻璃背板</td><td>塑料中框+玻璃背板</td></tr><tr><td>充电</td><td><font color="red">66w</font></td><td>65w</td><td><font color = "green">44w</font></td><td><font color="red">120w</font></td></tr><tr><td>重量三围</td><td><font color="red">154.2 * 70.1 * 7.6 mm 168g</font></td><td>156.8 * 72.1 * 7.59mm 182g</td><td>160.8 * 74.2 * 7.5mm 175 g</td><td><font color = "green">163.65 * 76.19 * 8.34mm 204g</font></td></tr><tr><td>定价</td><td><font color="red">8+128   2399元 </font>                  8+256   2699元</td><td>8+128   2799元    <font color = "green">12+256  3199元</font></td><td>8+128    2499元       8+256    2799元</td><td><font color="red">8+128    2199元 </font>           8+256    2699元</td></tr><tr><td>NFC</td><td><font color="red">有</font></td><td><font color ="green">无</font></td><td><font color="green">无</font></td><td><font color="red">有</font></td></tr><tr><td>系统</td><td><font color="red">华为智选12</font></td><td>Color OS 11.3</td><td>Origin OS 1.0</td><td><font color="green">MIUI 12.5</font></td></tr><tr><td>扬声器</td><td><font color="red">立体声双扬声器、双重Hi-Res认证、杜比全景声</font></td><td><font color="green">单扬声器</font></td><td><font color="green">单扬声器</font></td><td>双扬声器</td></tr></tbody></table><p><strong>综合以上对比可以得出未命名具有较强优势。</strong></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这周六自己选的公选课《产品的商业逻辑》就结课了，作为结课作业，我们需要完成一篇产品设计报告(内容不限，产品形态不限)。&lt;/p&gt;
&lt;p&gt;最后是选择了设计一台手机了事(&lt;del&gt;其实还没写完也没有画概念图&lt;/del&gt;)，在此感谢数码产品带佬 &lt;strong&gt;@寞落的风&lt;/strong&gt; 提供的帮助以及建议。&lt;/p&gt;
&lt;p&gt;细节之处可能不太符合逻辑，如有雷同，不胜荣幸。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="日常" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>马++参考书摘抄：多态与虚函数</title>
    <link href="http://example.com/2021/11/07/%E9%A9%AC-%E5%8F%82%E8%80%83%E4%B9%A6%E6%91%98%E6%8A%84%EF%BC%9A%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/11/07/%E9%A9%AC-%E5%8F%82%E8%80%83%E4%B9%A6%E6%91%98%E6%8A%84%EF%BC%9A%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-06T16:21:05.000Z</published>
    <updated>2021-11-22T16:30:33.479Z</updated>
    
    <content type="html"><![CDATA[<p><del>一看就知道我是上课没有好好听课。</del></p><p>内容摘抄自《C++程序设计精要教程》(编著 马光志)。</p><span id="more"></span><h3 id="8-1虚函数"><a href="#8-1虚函数" class="headerlink" title="8.1虚函数"></a>8.1虚函数</h3><h4 id="8-1-1-虚函数的声明和定义"><a href="#8-1-1-虚函数的声明和定义" class="headerlink" title="8.1.1 虚函数的声明和定义"></a>8.1.1 虚函数的声明和定义</h4><p>重载函数是一种静态多态函数， 虚函数是一种动态多态函数。 </p><p>当派生类中含有与基类虚函数同名的实例成员函数，其显式参数类型都应相同；当基类虚函数返回类型为基类指针p或者引用r时，派生类同名函数成员返回类型必须为可向p或者r赋值的基类/派生类指针(或引用)，其他情况两者的返回类型必须相同。</p><p><strong>C++中不允许将构造函数定义为虚函数或者纯虚函数。</strong></p><p>当基类中包含基类指针或者引用时，应将其析构函数定义为虚函数，所以一般可以将析构函数定义为虚函数。最好也将类的所有实例成员函数定义为虚函数。</p><p>当基类和派生类都定义了原型”相容”的虚函数时，如果基类指针指向的是派生类对象，则通过基类指针调用的是派生类的函数成员，否则调用基类的函数成员(基类引用引用了派生类对象同理)。</p><p>不能用<code>virtual</code>修饰类的友元函数，虚函数也不能定义为<code>constexpr</code>函数。</p><h4 id="8-1-2-虚函数的重载和内联"><a href="#8-1-2-虚函数的重载和内联" class="headerlink" title="8.1.2 虚函数的重载和内联"></a>8.1.2 虚函数的重载和内联</h4><p>基类与派生类定义的同名虚函数的访问权限可以不同。在C++的同一个类中，不能定义显式参数表(类型)完全相同、仅返回类型不同的静态成员函数或实例成员函数。    <strong>基类虚函数的特性会一直继承</strong>。</p><p>基类指针指向派生类对象时，调用成员函数时优先调用离该派生类最近的实例成员函数，若在该对象继承的类中都找不到所找函数时，才会调用基类对应的成员函数。若想限定使用某一级中的成员函数，可以用类名加作用域运算符 <strong>“::”</strong> 进行限定。　　</p><h5 id="关于内联inline"><a href="#关于内联inline" class="headerlink" title="关于内联inline"></a>关于内联inline</h5><p>虚函数可以申明为<code>inline</code>，具体到编译器解释时候，如果编译器在编译的时候就可以确定该虚函数的决议，则编译器以<code>inline</code>方式静态决议该虚函数。如果编译器在编译的时候不能决定，则必须在运行时决议虚函数，此时虚函数不能以<code>inline</code>函数的方式调用。</p><h5 id="关于友元friend和virtual、static"><a href="#关于友元friend和virtual、static" class="headerlink" title="关于友元friend和virtual、static"></a>关于友元friend和virtual、static</h5><p>因为<code>friend</code>声明的函数不是宿主类的函数成员，所以不能和<code>virtual</code>一起使用，除非被定义的函数已经是另一个类的虚函数成员；<code>friend</code>一般也不能跟<code>static</code>一起使用，除非<code>static</code>定义的函数是文件作用域内的静态函数或者其他类定义的静态函数。</p><p><code>virtual</code>一定不能与<code>static</code>一起使用，因为<code>static</code>定义的任何函数都不含隐含参数this，<code>virtual</code>则恰好相反。</p><h3 id="8-2-虚析构函数"><a href="#8-2-虚析构函数" class="headerlink" title="8.2 虚析构函数"></a>8.2 虚析构函数</h3><p>如果为基类和派生类的对象分配了动态内存，或者为派生类对象的成员分配了动态内存，在一定要将基类喝派生类的析构函数定义为虚函数，否则极有可能造成内存泄漏。</p><h3 id="8-3-类的引用"><a href="#8-3-类的引用" class="headerlink" title="8.3 类的引用"></a>8.3 类的引用</h3><p>引用变量是被引用实体的别名，被引用的对象应该自己负责构造和析构。</p><h4 id="8-3-1-类的引用变量及其析构"><a href="#8-3-1-类的引用变量及其析构" class="headerlink" title="8.3.1 类的引用变量及其析构"></a>8.3.1 类的引用变量及其析构</h4><p>如果类A的引用变量r引用了通过<strong>new</strong>生成的对象x，而在退出r的作用域之前没将x传到作用域之外(转移)，也没有主动去析构x和释放对象x所占用的内存，那么就应该用<code>delete &amp;r</code>析构x并释放他占用的内存(注意<code>r.~A()</code>仅用于析构x，而不能释放x占用的内存，从而造成内存泄露)。</p><p>当然，如果有址引用变量引用的对象不是通过<strong>new</strong>产生的，则引用变量无需负责对被引用的对象进行析构。</p><p>无址引用变量引用的是对象常量，由于移动语义的引入，被无址引用的常量对象的析构将推迟到该引用变量生命期的结束。所以虽然无址引用变量不负责常量对象的析构，但被其引用的常量对象的析构确实与变量的生命期有关。</p><h4 id="8-3-2-类的引用参数及其结构"><a href="#8-3-2-类的引用参数及其结构" class="headerlink" title="8.3.2 类的引用参数及其结构"></a>8.3.2 类的引用参数及其结构</h4><p>对形参不是引用类型而是对于一般对象类型来说，形参相当于局限于当前函数的局部变量。这种形参对象的构造是在调用时通过值参传递完成的，其析构则是在函数调用返回时完成的。    如果类定义了拷贝构造函数，将调用对应的拷贝函数完成。值参传递将实参对象数据成员的值相应地赋给形参对象的数据成员，而指针类型的数据成员只<strong>浅拷贝</strong>给形参对应指针成员。<br>所以一般要给类提供自定义的深拷贝构造函数以及移动构造函数。其中，移动构造函数通常实现为浅拷贝构造函数。</p><h3 id="8-4-抽象类"><a href="#8-4-抽象类" class="headerlink" title="8.4 抽象类"></a>8.4 抽象类</h3><h4 id="8-4-1-抽象类的定义"><a href="#8-4-1-抽象类的定义" class="headerlink" title="8.4.1 抽象类的定义"></a>8.4.1 抽象类的定义</h4><h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h5><p>纯虚函数是不必定义函数体的特殊虚函数，在定义虚函数时，在其后面添加 “=0” 表示其为纯虚函数。其他特性与一般虚函数区别不大。</p><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>含有纯虚函数的类就是抽象类，抽象类通常作为派生类的基类。如果派生类继承了抽象类的纯虚函数，又未定义原型”相容”且带函数体的虚函数；或者派生类又定义了新的纯虚函数，则当前的派生类还是抽象类。直到派生类中有一个类给所有继承来的纯虚函数定义了具体的函数体，该派生类才能成为非抽象类。<br>只有非抽象类才能产生对象。抽象类不能定义或产生任何对象，包括使用<strong>new</strong>创建对象、定义对象数组等等。不过，抽象类可以作为<strong>父类引用或者指针</strong>，用于引用或者指向子类中的具体对象。<br>抽象类指针或引用可以调用抽象类的纯虚函数，此时调用的一定是子类中关于该函数的具体实现(虚函数)。</p><h3 id="8-5-虚函数友元与晚期绑定"><a href="#8-5-虚函数友元与晚期绑定" class="headerlink" title="8.5 虚函数友元与晚期绑定"></a>8.5 虚函数友元与晚期绑定</h3><p>纯虚函数与一般虚函数一样，可以作为其他类的友元函数。不过一般不会将这种未定义函数体的函数作为友元。</p><h4 id="8-5-1-虚函数作为友元"><a href="#8-5-1-虚函数作为友元" class="headerlink" title="8.5.1 虚函数作为友元"></a>8.5.1 虚函数作为友元</h4><p>友元关系不能被传递或者继承。例如，类A的成员函数f( )是类B的友元，f( )可以访问B中所有成员，但是f()不能访问类B的派生类对象中的所有成员(除非f()也是其派生类的友元)。<br>同理，友元特性不能被继承关系传递，如A的函数<code>void f1(C &amp;)</code>作为友元，可以访问C类对象中的所有成员，但是A的派生类B中的<code>void B::f1(C &amp;)</code>不能访问类C的私有和保护成员。</p><h4 id="8-5-2-虚函数的晚期绑定"><a href="#8-5-2-虚函数的晚期绑定" class="headerlink" title="8.5.2 虚函数的晚期绑定"></a>8.5.2 虚函数的晚期绑定</h4><p> 举例说明，假定基类B及其派生类D都定义了虚函数，BD将分别产生虚函数地址表TB和TD。在构造D类对象d时，先将d作为基类B对象构造，故将TB首地址存放到d的起始单元，此时<code>B::B()</code>调用的虚函数将和TB中的虚函数绑定；当<code>B::B()</code>构造完毕，在执行D类构造函数<code>D::D()</code>之前，会将TD的首地址放到d的起始单元，此后<code>D::D()</code>调用的虚函数就会与TD中的虚函数进行绑定，即晚期绑定。<br>d析构的时候绑定顺序与构造时相反。这也说明子类对象的类型并不是固定的，在构造或者析构的某些时刻，子类对象可以被看作父类对象。</p><h3 id="8-6-有虚函数时的内存布局"><a href="#8-6-有虚函数时的内存布局" class="headerlink" title="8.6 有虚函数时的内存布局"></a>8.6 有虚函数时的内存布局</h3><h5 id="基类有虚函数时的内存布局"><a href="#基类有虚函数时的内存布局" class="headerlink" title="基类有虚函数时的内存布局"></a>基类有虚函数时的内存布局</h5><p>如果基类定义了虚函数或者纯虚函数，则派生类对象将共享基类对象的起始单元(存储单元)，用于存放虚函数地址表首址。</p><h5 id="基类无虚函数时的内存布局"><a href="#基类无虚函数时的内存布局" class="headerlink" title="基类无虚函数时的内存布局"></a>基类无虚函数时的内存布局</h5><p>如果基类没有定义虚函数，其单继承派生类定义了虚函数，则派生类的内存由三个部分组成：首先是继承自基类的内存，然后是派生类虚函数地址表首址，然后是该派生类中定义的实例数据成员。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;一看就知道我是上课没有好好听课。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;内容摘抄自《C++程序设计精要教程》(编著 马光志)。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++笔记: 类 (一)</title>
    <link href="http://example.com/2021/10/11/C-%E7%AC%94%E8%AE%B0-%E7%B1%BB-%E4%B8%80/"/>
    <id>http://example.com/2021/10/11/C-%E7%AC%94%E8%AE%B0-%E7%B1%BB-%E4%B8%80/</id>
    <published>2021-10-11T10:38:36.000Z</published>
    <updated>2021-11-22T16:51:19.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>C++是笔者这学期最重要的专业课之一。目前上课内容已简单介绍完C++的类的相关知识。</p><p>但是由于老师上课时的解析<del>经常听不懂</del>比较有深度，目前我对于C++类的认识还比较浅显，所以打算再花点时间自学并整理一遍相关内容。</p><p>参考书：《C++ Primer Plus》(第6版)，《C++程序设计精要教程》(编著 马光志)</p></blockquote><p>​    <span id="more"></span></p><h2 id="类的声明及定义"><a href="#类的声明及定义" class="headerlink" title="类的声明及定义"></a>类的声明及定义</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    类即类型的简称，用于描述对象的共同属性和方法。在C++中，类可以使用 <code>struct</code> 、<code>class</code> 或者 <code>union</code> 来定义。其中，类的属性用数据成员表示，类的方法用函数成员来表示。类的成员可以使用保留字 <code>private</code> 、<code>public</code> 或者 <code>protected</code> 来标识访问权限。</p><p>​    对象是类的实例，也就是某个类的值，它可以是一个变量，也可以是一个常量。类是一种__数据结构__，而对象代表了一段__内存__，存储了数据结构的值。当产生一个对象时，必须调用__构造函数__初始化对象；当一个对象“死亡”时，则需要调用__析构函数__释放对象占用的资源。</p><h3 id="关于访问控制"><a href="#关于访问控制" class="headerlink" title="关于访问控制"></a>关于访问控制</h3><p>​    关键字<code>private</code> 、<code>public</code> 和 <code>protected</code>描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但<u>只能通过公有成员函数 (或者友元函数) 来访问对象的私有成员</u>。</p><p>​    <code>private</code> 成员仅供<strong>同一类</strong>的成员函数访问；<code>protected</code> 成员仅供所在类及派生类的成员函数访问；<code>public</code> 成员可供任何成员或非成员函数访问。</p><p>​    无论类的数据成员还是成员函数，都可以在类的公有部分或者私有部分中声明它。通常把数据成员放在私有部分，组成类接口的成员函数放在公有部分。</p><p>​    不必在<strong>class类</strong>声明中使用关键字 <code>private</code> ，因为这是它的默认访问控制(注：struct和union定义的类成员默认访问权限为 <code>public</code>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">world</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> mass;<span class="comment">//默认是私有的</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>]<span class="comment">//私有</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>​    构造函数是类封装的特殊的实例函数成员，用于对对象的数据成员进行初始化，<u>对象必须初始化且仅能初始化一次</u>。 <strong>默认构造函数</strong>不能被显式调用。 </p><p>​    构造函数为对象申请各种资源用于初始化。除了隐含参数 <code>this</code> 外，构造函数还可以自带若干参数。</p><p>​    构造函数与类名同名。</p><p>​    <strong>需要注意的是</strong>，如果没有提供任何构造函数，则C++会自动提供<strong>默认构造函数</strong>，它不会做任何工作。对于某个类，如Stock类，默认构造函数可能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>() &#123;...&#125;<span class="comment">//参数表无参</span></span><br></pre></td></tr></table></figure><p>​    并且，<strong>当且仅当</strong>没有定义任何构造函数时，编译器才会提供默认构造函数。也就是说，为类定义了构造函数之后，程序员还必须为类提供默认构造函数。如果在定义前者之后未定义后者，以下声明将出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock stock1;</span><br></pre></td></tr></table></figure><p>​    通常用户定义的默认构造函数应可以给给所有成员提供隐式初始值。</p><p>​    构造函数既可以用于类的初始化，也可以用来给类赋新值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock stock2 = <span class="built_in">Stock</span>(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>);<span class="comment">//这里是初始化，可能会创建新的临时对象（看编译器）用于赋值</span></span><br><span class="line">stock1 = <span class="built_in">Stock</span>(<span class="string">&quot;Niftty Foods&quot;</span>, <span class="number">10</span>, <span class="number">50.0</span>);<span class="comment">//这里是赋值而不是初始化，实际上创建了一个新的对象，然后将其内容复制给stock1</span></span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>​    析构函数也是类封装的特殊的实例函数成员，其特点是和类名同名且名前带有<strong>“ ~ ”</strong>，同时，无论是程序自定义还是C++默认生成的析构函数，都只能有一个隐含参数 <code>this</code> 。  析构函数可以被显式调用。</p><p>​    析构函数用于对数据成员申请的资源进行回收，如果构造函数为类成员动态分配了内存（如<strong>new</strong>），则析构函数相应地要释放这些内存（<strong>delete</strong>）。与构造函数不同，析构函数可以执行多次，但是应当尽量避免资源被多次释放。</p><p>​    构造函数和析构函数都不可以定义返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STRING</span>//定义了一个名为<span class="title">STRING</span>的类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span>* CHARPTR;<span class="comment">//定义类型成员</span></span><br><span class="line">    CHARPTR s;<span class="comment">//定义数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">()</span></span>;<span class="comment">//定义函数成员</span></span><br><span class="line">    <span class="built_in">STRING</span>(<span class="keyword">const</span> <span class="keyword">char</span>*);<span class="comment">//定义构造函数</span></span><br><span class="line">    ~<span class="built_in">STRING</span>();<span class="comment">//定义析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">STRING <span class="title">y</span><span class="params">(<span class="string">&quot;complex&quot;</span>)</span></span>;<span class="comment">//自动调用构造函数STRING(&quot;complex&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-11-列表初始化"><a href="#C-11-列表初始化" class="headerlink" title="C++11 列表初始化"></a>C++11 列表初始化</h3><p>​    在<strong>C++11</strong>中，可以将列表初始化语法应用于类，只要提供与某个构造函数的参数列表匹配的内容即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock hot_tip = &#123;<span class="string">&quot;...&quot;</span>, <span class="number">100</span>, <span class="number">45.0</span>&#125;;<span class="comment">//可与构造函数Stock(const string &amp;co, long n = 0, double pr = 0.0)匹配</span></span><br><span class="line">Stock temp = &#123;&#125;;<span class="comment">//可与无参的默认构造函数Stock()匹配</span></span><br></pre></td></tr></table></figure><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Stock land = <span class="built_in">Stock</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">land.<span class="built_in">show</span>();<span class="comment">//假设show()是Stock的成员函数</span></span><br></pre></td></tr></table></figure><p>​    假如有如上代码片段，对于当前的C++，编译器会拒绝第二行。因为show()的代码可能不能保证调用对象不被修改——调用对象就跟const一样不应被修改。对于没有任何参数的成员函数，我们并不能通过将函数参数声明为const引用或指向const的指针来解决问题。这里的解决方法是将const关键字加到函数的括号后面，即相关函数的定义和声明应如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//保证函数不修改对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>​    以这种方式声明和定义的类函数被称为<strong>const成员函数</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;C++是笔者这学期最重要的专业课之一。目前上课内容已简单介绍完C++的类的相关知识。&lt;/p&gt;
&lt;p&gt;但是由于老师上课时的解析&lt;del&gt;经常听不懂&lt;/del&gt;比较有深度，目前我对于C++类的认识还比较浅显，所以打算再花点时间自学并整理一遍相关内容。&lt;/p&gt;
&lt;p&gt;参考书：《C++ Primer Plus》(第6版)，《C++程序设计精要教程》(编著 马光志)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​</summary>
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
</feed>
