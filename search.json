[{"title":"C++笔记: 类 (一)","url":"/2021/10/11/C-%E7%AC%94%E8%AE%B0-%E7%B1%BB-%E4%B8%80/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>C++是笔者这学期最重要的专业课之一。目前上课内容已简单介绍完C++的类的相关知识。</p>\n<p>但是由于老师上课时的解析<del>经常听不懂</del>比较有深度，目前我对于C++类的认识还比较浅显，所以打算再花点时间自学并整理一遍相关内容。</p>\n<p>参考书：《C++ Primer Plus》(第6版)，《C++程序设计精要教程》(编著 马光志)</p>\n</blockquote>\n<p>​    <span id=\"more\"></span></p>\n<h2 id=\"类的声明及定义\"><a href=\"#类的声明及定义\" class=\"headerlink\" title=\"类的声明及定义\"></a>类的声明及定义</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>​    类即类型的简称，用于描述对象的共同属性和方法。在C++中，类可以使用 <code>struct</code> 、<code>class</code> 或者 <code>union</code> 来定义。其中，类的属性用数据成员表示，类的方法用函数成员来表示。类的成员可以使用保留字 <code>private</code> 、<code>public</code> 或者 <code>protected</code> 来标识访问权限。</p>\n<p>​    对象是类的实例，也就是某个类的值，它可以是一个变量，也可以是一个常量。类是一种__数据结构__，而对象代表了一段__内存__，存储了数据结构的值。当产生一个对象时，必须调用__构造函数__初始化对象；当一个对象“死亡”时，则需要调用__析构函数__释放对象占用的资源。</p>\n<h3 id=\"关于访问控制\"><a href=\"#关于访问控制\" class=\"headerlink\" title=\"关于访问控制\"></a>关于访问控制</h3><p>​    关键字<code>private</code> 、<code>public</code> 和 <code>protected</code>描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但<u>只能通过公有成员函数 (或者友元函数) 来访问对象的私有成员</u>。</p>\n<p>​    <code>private</code> 成员仅供<strong>同一类</strong>的成员函数访问；<code>protected</code> 成员仅供所在类及派生类的成员函数访问；<code>public</code> 成员可供任何成员或非成员函数访问。</p>\n<p>​    无论类的数据成员还是成员函数，都可以在类的公有部分或者私有部分中声明它。通常把数据成员放在私有部分，组成类接口的成员函数放在公有部分。</p>\n<p>​    不必在<strong>class类</strong>声明中使用关键字 <code>private</code> ，因为这是它的默认访问控制(注：struct和union定义的类成员默认访问权限为 <code>public</code>)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">world</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> mass;\t\t<span class=\"comment\">//默认是私有的</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">20</span>]\t<span class=\"comment\">//私有</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>​    构造函数是类封装的特殊的实例函数成员，用于对对象的数据成员进行初始化，<u>对象必须初始化且仅能初始化一次</u>。 <strong>默认构造函数</strong>不能被显式调用。 </p>\n<p>​    构造函数为对象申请各种资源用于初始化。除了隐含参数 <code>this</code> 外，构造函数还可以自带若干参数。</p>\n<p>​    构造函数与类名同名。</p>\n<p>​    <strong>需要注意的是</strong>，如果没有提供任何构造函数，则C++会自动提供<strong>默认构造函数</strong>，它不会做任何工作。对于某个类，如Stock类，默认构造函数可能如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stock::<span class=\"built_in\">Stock</span>() &#123;...&#125;\t<span class=\"comment\">//参数表无参</span></span><br></pre></td></tr></table></figure>\n\n<p>​    并且，<strong>当且仅当</strong>没有定义任何构造函数时，编译器才会提供默认构造函数。也就是说，为类定义了构造函数之后，程序员还必须为类提供默认构造函数。如果在定义前者之后未定义后者，以下声明将出错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stock stock1;</span><br></pre></td></tr></table></figure>\n\n<p>​    通常用户定义的默认构造函数应可以给给所有成员提供隐式初始值。</p>\n<p>​    构造函数既可以用于类的初始化，也可以用来给类赋新值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stock stock2 = <span class=\"built_in\">Stock</span>(<span class=\"string\">&quot;Boffo Objects&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">2.0</span>);\t<span class=\"comment\">//这里是初始化，可能会创建新的临时对象（看编译器）用于赋值</span></span><br><span class=\"line\">stock1 = <span class=\"built_in\">Stock</span>(<span class=\"string\">&quot;Niftty Foods&quot;</span>, <span class=\"number\">10</span>, <span class=\"number\">50.0</span>);\t<span class=\"comment\">//这里是赋值而不是初始化，实际上创建了一个新的对象，然后将其内容复制给stock1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>​    析构函数也是类封装的特殊的实例函数成员，其特点是和类名同名且名前带有<strong>“ ~ ”</strong>，同时，无论是程序自定义还是C++默认生成的析构函数，都只能有一个隐含参数 <code>this</code> 。  析构函数可以被显式调用。</p>\n<p>​    析构函数用于对数据成员申请的资源进行回收，如果构造函数为类成员动态分配了内存（如<strong>new</strong>），则析构函数相应地要释放这些内存（<strong>delete</strong>）。与构造函数不同，析构函数可以执行多次，但是应当尽量避免资源被多次释放。</p>\n<p>​    构造函数和析构函数都不可以定义返回类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">STRING</span>\t\t\t\t//定义了一个名为<span class=\"title\">STRING</span>的类</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span>* CHARPTR;\t<span class=\"comment\">//定义类型成员</span></span><br><span class=\"line\">    CHARPTR s;\t\t\t\t<span class=\"comment\">//定义数据成员</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strlen</span><span class=\"params\">()</span></span>;\t\t\t<span class=\"comment\">//定义函数成员</span></span><br><span class=\"line\">    <span class=\"built_in\">STRING</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*);\t<span class=\"comment\">//定义构造函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">STRING</span>();\t\t\t\t<span class=\"comment\">//定义析构函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">STRING <span class=\"title\">y</span><span class=\"params\">(<span class=\"string\">&quot;complex&quot;</span>)</span></span>;\t<span class=\"comment\">//自动调用构造函数STRING(&quot;complex&quot;)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"C-11-列表初始化\"><a href=\"#C-11-列表初始化\" class=\"headerlink\" title=\"C++11 列表初始化\"></a>C++11 列表初始化</h3><p>​    在<strong>C++11</strong>中，可以将列表初始化语法应用于类，只要提供与某个构造函数的参数列表匹配的内容即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stock hot_tip = &#123;<span class=\"string\">&quot;...&quot;</span>, <span class=\"number\">100</span>, <span class=\"number\">45.0</span>&#125;;\t<span class=\"comment\">//可与构造函数Stock(const string &amp;co, long n = 0, double pr = 0.0)匹配</span></span><br><span class=\"line\">Stock temp = &#123;&#125;;\t<span class=\"comment\">//可与无参的默认构造函数Stock()匹配</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"const成员函数\"><a href=\"#const成员函数\" class=\"headerlink\" title=\"const成员函数\"></a>const成员函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Stock land = <span class=\"built_in\">Stock</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">land.<span class=\"built_in\">show</span>();\t<span class=\"comment\">//假设show()是Stock的成员函数</span></span><br></pre></td></tr></table></figure>\n\n<p>​    假如有如上代码片段，对于当前的C++，编译器会拒绝第二行。因为show()的代码可能不能保证调用对象不被修改——调用对象就跟const一样不应被修改。对于没有任何参数的成员函数，我们并不能通过将函数参数声明为const引用或指向const的指针来解决问题。这里的解决方法是将const关键字加到函数的括号后面，即相关函数的定义和声明应如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;\t<span class=\"comment\">//保证函数不修改对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Stock::show</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>​    以这种方式声明和定义的类函数被称为<strong>const成员函数</strong>。</p>\n","categories":["学习"],"tags":["C++"]},{"title":"(转载)人文摄影中如何拍摄陌生人","url":"/2021/11/26/%E4%BA%BA%E6%96%87%E6%91%84%E5%BD%B1%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8B%8D%E6%91%84%E9%99%8C%E7%94%9F%E4%BA%BA/","content":"<p><a href=\"https://imgtu.com/i/oZsYVA\"><img src=\"https://z3.ax1x.com/2021/11/26/oZsYVA.jpg\" alt=\"oZsYVA.jpg\" border=\"0\"/></a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>人文摄影每个人的定义都不同，我觉得本质就是关注人的生活状态的摄影活动。通常人文照片当中除了人（主体）以外，还会有背景、线条、符号等引出照片的故事（氛围），这五点称为照片的五要素。这里就不展开了 ，只简单介绍下我自己拍摄人文照片的三个拍摄陌生人的方法和拍摄方法。</p>\n</blockquote>\n<p>(本文经授权转载自酷安用户 @<strong>Atmogz</strong> 图文 《人文摄影中如何拍摄陌生人》)</p>\n<span id=\"more\"></span>\n\n<h3 id=\"人像照与人文照\"><a href=\"#人像照与人文照\" class=\"headerlink\" title=\"人像照与人文照\"></a>人像照与人文照</h3><p>陌生人的人像照（指还是能交待环境，不是过度虚化的人文类人像照）与人文照有相同点，也有很大的不同点，先对比下人像照片和人文照片有什么区别。 </p>\n<a href=\"https://imgtu.com/i/oZyMon\">\n\n<img src=\"https://z3.ax1x.com/2021/11/26/oZyMon.jpg\" alt=\"oZyMon.jpg\" border=\"0\"  width=\"500\" height=\"332\" align=\"center\"/>\n\n</a>\n\n<p>人像照片通常我们需要通过构图或虚化来尽量避开杂乱的背景。看下图可知道我是蹲下从下向上拍摄，避开周围的杂乱背景，通过<strong>90mm左右</strong>的焦段压缩感，让3个小朋友更显亲密，光圈通常我只用<strong>f8或更小</strong>，不会过度虚化背景。 </p>\n<a href=\"https://imgtu.com/i/oZcta9\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZcta9.jpg\" alt=\"oZcta9.jpg\" border=\"0\" border=\"0\"  width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>这张同行伙伴所拍的就是典型的人文照片，<strong>主体</strong>（拍摄者与被拍摄者），<strong>背景</strong>（屋顶倒塌的房子与救灾帐篷，反映出拍摄地点是在地震过后的人们生活区），<strong>符号</strong>（背景当中的人与小卖部，反映出生活区中人们的生活状况），这几个要素反映了出这张照片要说的故事。</p>\n<p>通过上面两张照片，知道人像照是要<u>突出人物，尽量减少背景中的干扰</u>，当然也可用拍人文的方法拍摄人像照，以交代被拍摄人物的生活或工作场景。而人文照是通过照片中的人和背景以及当中的符号 来讲故事的。可以简单理解为写叙述文那要，要有人物、地点、时间（当然照片反映不出时间），用以反映发生了什么故事。</p>\n<h3 id=\"人文摄影方式\"><a href=\"#人文摄影方式\" class=\"headerlink\" title=\"人文摄影方式\"></a>人文摄影方式</h3><p>人文摄影拍摄人物一般有：<strong>沟通</strong>、<strong>等待</strong>、<strong>抓拍</strong>三种方式。</p>\n<h4 id=\"沟通\"><a href=\"#沟通\" class=\"headerlink\" title=\"沟通\"></a>沟通</h4><p>沟通并不是生硬地突然去问被拍摄者愿不愿意被拍，而是应该有前期铺垫，先和人物聊会天，一般围绕我们想拍的环境或事物展开就行。沟通后被拍摄者往往不会介意被拍，有的还更加配合。</p>\n<p>其实人文摄影在拍摄前应该多去和当地人沟通（找间老店或坐树头的老人家，如杂货店），了解当下环境的过往，最好是有什么故事，这样对拍摄会更有帮助（比如可以根据故事去拍摄，拍摄后写照片介绍也更有趣）。 </p>\n<a href=\"https://imgtu.com/i/oZgARx\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZgARx.jpg\" alt=\"oZgARx.jpg\" border=\"0\"  width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>这组照片我要拍摄的主体是这间一看就很有历史的理发店，人物反而是符号。人文照片的构图我会尽量简少透视感的干扰，用比较平稳的构图减少观看者对画面外的猜想，以突出画面内容。 </p>\n<a href=\"https://imgtu.com/i/oZgawQ\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZgawQ.jpg\" alt=\"oZgawQ.jpg\"  border=\"0\"  width=\"500\" height=\"337\" align=\"center\"/>\n\n</a>\n\n<p>沟通后就能慢慢拍摄，可以用不同构图多拍几张去挑选。像这张贴着橱窗拍摄时，抬起镜头让部分玻璃的反射物也拍摄到，让观看者知道是隔着玻璃拍摄的。 </p>\n<a href=\"https://imgtu.com/i/oZgdoj\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZgdoj.jpg\" alt=\"oZgdoj.jpg\" border=\"0\" width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>和理发店里面的老人家沟通内容是围绕这间店的历史，比如没入镜有60多年历史的吊扇和这张解放前就有的理发椅。这张椅子也就成为了这张照片的主体，理发师（据说是第三代了）和顾客只是这店的符号。符号可以理解为反映主体所在地或主体在做什么的事物，如上面帐篷区的小卖部与人们、拿剪发剪的理发师、戴着厨师帽的厨师等…… </p>\n<a href=\"https://imgtu.com/i/oZ2ucV\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2ucV.jpg\" alt=\"oZ2ucV.jpg\" border=\"0\" width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>要拍某些人物，可从他们所做的事情开始聊起。像这两张人像照，我是先和同行的小朋友说老人家做的竹艺不错，而且单用一把竹刀就行，要有几十年功力才能做到（吹捧手艺或工作）。接着才和老人家聊天，一面聊一面拍照，老人家兴奋起来还点上烟来上几张。这两张照片主要表达的是老人家的手艺，所以就没过多去拍环境，只保留背景中的竹林。 </p>\n<a href=\"https://imgtu.com/i/oZ2Ekj\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2Ekj.jpg\" alt=\"oZ2Ekj.jpg\" border=\"0\" width=\"281\" height=\"500\" align=\"center\"/>\n\n</a>\n\n<p>有时候有想拍场景与人物，但没有能切入沟通的点，也是只能直接询问被拍人物，征得同议后再拍。当我发现这电线杆有免费充电口后，每天会故意经过这里，想拍下有人在充电的照片（以反映有人在使用城市免费提供的便利设施场景）。三天里不是没人，就是流浪者在这充电，我都是上前直接询问能否拍下他在这充电的场景，前两个流浪者都很抗据就没有拍照直接走人，问到第三个流浪者才同意让我拍摄。照片使用了手机的超广角进行拍摄，让视觉冲击更强。（一般情况下人文照我有三不拍：流浪者不拍，残疾人不拍，争吵打架不拍。这三类人心理相对比较敏感，为了自身和器材的安全……）</p>\n<h4 id=\"等待\"><a href=\"#等待\" class=\"headerlink\" title=\"等待\"></a>等待</h4><p>偶尔发现一个不错的场景想拍，又不想和路人有沟通，可以举着相机对着想拍的场景，动作幅度要大点，显得很大方的样子。等待路人或拍摄的人物进入，构图合适才按下快门。这个是解决拍摄陌生人尴尬，和怕别人不愿意被拍的好方法。</p>\n<p>大大方方举着相机，路人经过一般能看到我们，就不会觉得我们是在故意拍他们（这也是一种前期铺垫），不愿意被拍的一般会躲开，没所谓或没留意的就会走入画面。哪怕路人被拍摄后才发觉而有意见，也不会有太大反应，即时删掉照片再举起相机就行。 </p>\n<a href=\"https://imgtu.com/i/oZ2Vts\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2Vts.jpg\" alt=\"oZ2Vts.jpg\" border=\"0\" width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>这个场景拍摄了不少于三分钟，拍摄了十几张后才挑选出这张对于街头表演不同有反应的路人照。 </p>\n<a href=\"https://imgtu.com/i/oZ2QnU\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2QnU.jpg\" alt=\"oZ2QnU.jpg\" border=\"0\" width=\"375\" height=\"500\" align=\"center\" />\n\n</a>\n\n<p>这张举着手机等远处的小朋友走近后才按快门，近处小朋友的妈妈还主动让开，过来看着我的手机画面。</p>\n<h4 id=\"抓拍\"><a href=\"#抓拍\" class=\"headerlink\" title=\"抓拍\"></a>抓拍</h4><p>这方法就不举例了。</p>\n<p>最后聊聊拍摄人文照所用的镜头焦段，我个人比较喜欢用28mm、35mm、50mm这三个焦段，只有当距离拍摄场景太远，而且跑不过去的情况下才会用更长的焦段。</p>\n<p>原因有：</p>\n<ol>\n<li>广角到标镜范围能近距离拍到更大的场景</li>\n<li>方便与被拍摄人物的交流</li>\n<li>更容易观察到被拍摄者的表情以及眼神光</li>\n<li>光线不好的时候，被拍摄者能反射更多的光线</li>\n<li>减轻环境中其它的光线干扰，特别是室内环境</li>\n</ol>\n<p>下面用两张在自然光下，拍摄人文类人像照典型的用光方式的照片举例说明。 </p>\n<a href=\"https://imgtu.com/i/oZ2k7Q\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2k7Q.jpg\" alt=\"oZ2k7Q.jpg\" border=\"0\" width=\"500\" height=\"333\" align=\"center\"/>\n\n</a>\n\n<p>让人物在室内（或树荫下），面向室外（门口或窗户），柔和的自然光（面积光）会减少人物的阴影，让人物皮肤更显柔和（适合拍女性人像），也容易形成漂亮的眼神光，缺点就是人物的立体感不强。在这样弱光环境下，最好是用28mm-50mm焦段拍摄，用长焦的话就需要更大的光圈拍摄才行，大光圈就容易过度虚化背景，也就丢失了背景环境。 </p>\n<a href=\"https://imgtu.com/i/oZ2Zhn\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2Zhn.jpg\" alt=\"oZ2Zhn.jpg\" border=\"0\" width=\"500\" height=\"333\" align=\"center\"/>\n\n</a>\n\n<p>另一种方式是让人物在室内（或树荫下），侧面对着户外。侧光会让人物的更具立体感，缺点就是明暗对比会过强，皮肤不够柔和（适合拍中老年人，更显沧桑），难以形成漂亮的眼神光。在这类光照场景中，为了让暗部细节不会丢失过多，就需要更加靠近被拍人物拍摄。28mm-50mm焦段自然就是理想焦段了，和上面一样用长焦拍摄的话就需要更大光圈，会丢失背景环境。</p>\n<p>另外还有一个很少摄影教材会写的在自然光下用28mm-50mm拍摄的好处。 </p>\n<a href=\"https://imgtu.com/i/oZ2KXT\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2KXT.jpg\" alt=\"oZ2KXT.jpg\" border=\"0\" width=\"500\" height=\"333\" align=\"center\"/>\n\n</a>\n\n<p>在午间强烈的阳光下，我们可以让被拍摄者背向太阳，稍微低头避免脸上的明暗对比过强。但没有闪光灯或反光板补光，人物的脸就容易过暗。这时候靠近拍摄，摄影师衣服的反光也能作为补光（特别是穿白色衣服），留意照片中小朋友的眼神光不是天空形成，而是我身上的白T恤反射形成。 </p>\n<a href=\"https://imgtu.com/i/oZ2n10\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2n10.jpg\" alt=\"oZ2n10.jpg\" border=\"0\" width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>同样是午间拍摄的小女孩，眼神光是由蔬菜反射光形成的，自然也给小女孩的脸补光了。</p>\n<p>有没发现眼神光是能让人文类人像照感动观看者的利器，这也是为什么说28mm-50mm是人文摄影师常用的焦段，还有大多人像照只拍摄半身甚至胸部以上的原因。</p>\n<p>希望这几个人文摄影的小技巧对大家拍摄人文照有所帮助。</p>\n","categories":["随笔"],"tags":["日常"]},{"title":"马++参考书摘抄：多态与虚函数","url":"/2021/11/07/%E9%A9%AC-%E5%8F%82%E8%80%83%E4%B9%A6%E6%91%98%E6%8A%84%EF%BC%9A%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/","content":"<p><del>一看就知道我是上课没有好好听课。</del></p>\n<p>内容摘抄自《C++程序设计精要教程》(编著 马光志)。</p>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"8-1虚函数\"><a href=\"#8-1虚函数\" class=\"headerlink\" title=\"8.1虚函数\"></a>8.1虚函数</h3><h4 id=\"8-1-1-虚函数的声明和定义\"><a href=\"#8-1-1-虚函数的声明和定义\" class=\"headerlink\" title=\"8.1.1 虚函数的声明和定义\"></a>8.1.1 虚函数的声明和定义</h4><p>重载函数是一种静态多态函数， 虚函数是一种动态多态函数。 </p>\n<p>当派生类中含有与基类虚函数同名的实例成员函数，其显式参数类型都应相同；当基类虚函数返回类型为基类指针p或者引用r时，派生类同名函数成员返回类型必须为可向p或者r赋值的基类/派生类指针(或引用)，其他情况两者的返回类型必须相同。</p>\n<p><strong>C++中不允许将构造函数定义为虚函数或者纯虚函数。</strong></p>\n<p>当基类中包含基类指针或者引用时，应将其析构函数定义为虚函数，所以一般可以将析构函数定义为虚函数。最好也将类的所有实例成员函数定义为虚函数。</p>\n<p>当基类和派生类都定义了原型”相容”的虚函数时，如果基类指针指向的是派生类对象，则通过基类指针调用的是派生类的函数成员，否则调用基类的函数成员(基类引用引用了派生类对象同理)。</p>\n<p>不能用<code>virtual</code>修饰类的友元函数，虚函数也不能定义为<code>constexpr</code>函数。</p>\n<h4 id=\"8-1-2-虚函数的重载和内联\"><a href=\"#8-1-2-虚函数的重载和内联\" class=\"headerlink\" title=\"8.1.2 虚函数的重载和内联\"></a>8.1.2 虚函数的重载和内联</h4><p>基类与派生类定义的同名虚函数的访问权限可以不同。在C++的同一个类中，不能定义显式参数表(类型)完全相同、仅返回类型不同的静态成员函数或实例成员函数。    <strong>基类虚函数的特性会一直继承</strong>。</p>\n<p>基类指针指向派生类对象时，调用成员函数时优先调用离该派生类最近的实例成员函数，若在该对象继承的类中都找不到所找函数时，才会调用基类对应的成员函数。若想限定使用某一级中的成员函数，可以用类名加作用域运算符 <strong>“::”</strong> 进行限定。\n　　</p>\n<h5 id=\"关于内联inline\"><a href=\"#关于内联inline\" class=\"headerlink\" title=\"关于内联inline\"></a>关于内联inline</h5><p>虚函数可以申明为<code>inline</code>，具体到编译器解释时候，如果编译器在编译的时候就可以确定该虚函数的决议，则编译器以<code>inline</code>方式静态决议该虚函数。如果编译器在编译的时候不能决定，则必须在运行时决议虚函数，此时虚函数不能以<code>inline</code>函数的方式调用。</p>\n<h5 id=\"关于友元friend和virtual、static\"><a href=\"#关于友元friend和virtual、static\" class=\"headerlink\" title=\"关于友元friend和virtual、static\"></a>关于友元friend和virtual、static</h5><p>因为<code>friend</code>声明的函数不是宿主类的函数成员，所以不能和<code>virtual</code>一起使用，除非被定义的函数已经是另一个类的虚函数成员；<code>friend</code>一般也不能跟<code>static</code>一起使用，除非<code>static</code>定义的函数是文件作用域内的静态函数或者其他类定义的静态函数。</p>\n<p><code>virtual</code>一定不能与<code>static</code>一起使用，因为<code>static</code>定义的任何函数都不含隐含参数this，<code>virtual</code>则恰好相反。</p>\n<h3 id=\"8-2-虚析构函数\"><a href=\"#8-2-虚析构函数\" class=\"headerlink\" title=\"8.2 虚析构函数\"></a>8.2 虚析构函数</h3><p>如果为基类和派生类的对象分配了动态内存，或者为派生类对象的成员分配了动态内存，在一定要将基类喝派生类的析构函数定义为虚函数，否则极有可能造成内存泄漏。</p>\n<h3 id=\"8-3-类的引用\"><a href=\"#8-3-类的引用\" class=\"headerlink\" title=\"8.3 类的引用\"></a>8.3 类的引用</h3><p>引用变量是被引用实体的别名，被引用的对象应该自己负责构造和析构。</p>\n<h4 id=\"8-3-1-类的引用变量及其析构\"><a href=\"#8-3-1-类的引用变量及其析构\" class=\"headerlink\" title=\"8.3.1 类的引用变量及其析构\"></a>8.3.1 类的引用变量及其析构</h4><p>如果类A的引用变量r引用了通过<strong>new</strong>生成的对象x，而在退出r的作用域之前没将x传到作用域之外(转移)，也没有主动去析构x和释放对象x所占用的内存，那么就应该用<code>delete &amp;r</code>析构x并释放他占用的内存(注意<code>r.~A()</code>仅用于析构x，而不能释放x占用的内存，从而造成内存泄露)。</p>\n<p>当然，如果有址引用变量引用的对象不是通过<strong>new</strong>产生的，则引用变量无需负责对被引用的对象进行析构。</p>\n<p>无址引用变量引用的是对象常量，由于移动语义的引入，被无址引用的常量对象的析构将推迟到该引用变量生命期的结束。所以虽然无址引用变量不负责常量对象的析构，但被其引用的常量对象的析构确实与变量的生命期有关。</p>\n<h4 id=\"8-3-2-类的引用参数及其结构\"><a href=\"#8-3-2-类的引用参数及其结构\" class=\"headerlink\" title=\"8.3.2 类的引用参数及其结构\"></a>8.3.2 类的引用参数及其结构</h4><p>对形参不是引用类型而是对于一般对象类型来说，形参相当于局限于当前函数的局部变量。这种形参对象的构造是在调用时通过值参传递完成的，其析构则是在函数调用返回时完成的。    如果类定义了拷贝构造函数，将调用对应的拷贝函数完成。值参传递将实参对象数据成员的值相应地赋给形参对象的数据成员，而指针类型的数据成员只<strong>浅拷贝</strong>给形参对应指针成员。<br>所以一般要给类提供自定义的深拷贝构造函数以及移动构造函数。其中，移动构造函数通常实现为浅拷贝构造函数。</p>\n<h3 id=\"8-4-抽象类\"><a href=\"#8-4-抽象类\" class=\"headerlink\" title=\"8.4 抽象类\"></a>8.4 抽象类</h3><h4 id=\"8-4-1-抽象类的定义\"><a href=\"#8-4-1-抽象类的定义\" class=\"headerlink\" title=\"8.4.1 抽象类的定义\"></a>8.4.1 抽象类的定义</h4><h5 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h5><p>纯虚函数是不必定义函数体的特殊虚函数，在定义虚函数时，在其后面添加 “=0” 表示其为纯虚函数。其他特性与一般虚函数区别不大。</p>\n<h5 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h5><p>含有纯虚函数的类就是抽象类，抽象类通常作为派生类的基类。如果派生类继承了抽象类的纯虚函数，又未定义原型”相容”且带函数体的虚函数；或者派生类又定义了新的纯虚函数，则当前的派生类还是抽象类。直到派生类中有一个类给所有继承来的纯虚函数定义了具体的函数体，该派生类才能成为非抽象类。<br>只有非抽象类才能产生对象。抽象类不能定义或产生任何对象，包括使用<strong>new</strong>创建对象、定义对象数组等等。不过，抽象类可以作为<strong>父类引用或者指针</strong>，用于引用或者指向子类中的具体对象。<br>抽象类指针或引用可以调用抽象类的纯虚函数，此时调用的一定是子类中关于该函数的具体实现(虚函数)。</p>\n<h3 id=\"8-5-虚函数友元与晚期绑定\"><a href=\"#8-5-虚函数友元与晚期绑定\" class=\"headerlink\" title=\"8.5 虚函数友元与晚期绑定\"></a>8.5 虚函数友元与晚期绑定</h3><p>纯虚函数与一般虚函数一样，可以作为其他类的友元函数。不过一般不会将这种未定义函数体的函数作为友元。</p>\n<h4 id=\"8-5-1-虚函数作为友元\"><a href=\"#8-5-1-虚函数作为友元\" class=\"headerlink\" title=\"8.5.1 虚函数作为友元\"></a>8.5.1 虚函数作为友元</h4><p>友元关系不能被传递或者继承。例如，类A的成员函数f( )是类B的友元，f( )可以访问B中所有成员，但是f()不能访问类B的派生类对象中的所有成员(除非f()也是其派生类的友元)。<br>同理，友元特性不能被继承关系传递，如A的函数<code>void f1(C &amp;)</code>作为友元，可以访问C类对象中的所有成员，但是A的派生类B中的<code>void B::f1(C &amp;)</code>不能访问类C的私有和保护成员。</p>\n<h4 id=\"8-5-2-虚函数的晚期绑定\"><a href=\"#8-5-2-虚函数的晚期绑定\" class=\"headerlink\" title=\"8.5.2 虚函数的晚期绑定\"></a>8.5.2 虚函数的晚期绑定</h4><p> 举例说明，假定基类B及其派生类D都定义了虚函数，BD将分别产生虚函数地址表TB和TD。在构造D类对象d时，先将d作为基类B对象构造，故将TB首地址存放到d的起始单元，此时<code>B::B()</code>调用的虚函数将和TB中的虚函数绑定；当<code>B::B()</code>构造完毕，在执行D类构造函数<code>D::D()</code>之前，会将TD的首地址放到d的起始单元，此后<code>D::D()</code>调用的虚函数就会与TD中的虚函数进行绑定，即晚期绑定。<br>d析构的时候绑定顺序与构造时相反。这也说明子类对象的类型并不是固定的，在构造或者析构的某些时刻，子类对象可以被看作父类对象。</p>\n<h3 id=\"8-6-有虚函数时的内存布局\"><a href=\"#8-6-有虚函数时的内存布局\" class=\"headerlink\" title=\"8.6 有虚函数时的内存布局\"></a>8.6 有虚函数时的内存布局</h3><h5 id=\"基类有虚函数时的内存布局\"><a href=\"#基类有虚函数时的内存布局\" class=\"headerlink\" title=\"基类有虚函数时的内存布局\"></a>基类有虚函数时的内存布局</h5><p>如果基类定义了虚函数或者纯虚函数，则派生类对象将共享基类对象的起始单元(存储单元)，用于存放虚函数地址表首址。</p>\n<h5 id=\"基类无虚函数时的内存布局\"><a href=\"#基类无虚函数时的内存布局\" class=\"headerlink\" title=\"基类无虚函数时的内存布局\"></a>基类无虚函数时的内存布局</h5><p>如果基类没有定义虚函数，其单继承派生类定义了虚函数，则派生类的内存由三个部分组成：首先是继承自基类的内存，然后是派生类虚函数地址表首址，然后是该派生类中定义的实例数据成员。</p>\n","categories":["学习"],"tags":["C++"]}]