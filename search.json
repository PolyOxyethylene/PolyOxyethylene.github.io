[{"title":"C++笔记: 类 (一)","url":"/2021/10/11/C-%E7%AC%94%E8%AE%B0-%E7%B1%BB-%E4%B8%80/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>C++是笔者这学期最重要的专业课之一。目前上课内容已简单介绍完C++的类的相关知识。</p>\n<p>但是由于老师上课时的解析<del>经常听不懂</del>比较有深度，目前我对于C++类的认识还比较浅显，所以打算再花点时间自学并整理一遍相关内容。</p>\n<p>参考书：《C++ Primer Plus》(第6版)，《C++程序设计精要教程》(编著 马光志)</p>\n</blockquote>\n<p>​    <span id=\"more\"></span></p>\n<h2 id=\"类的声明及定义\"><a href=\"#类的声明及定义\" class=\"headerlink\" title=\"类的声明及定义\"></a>类的声明及定义</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>​    类即类型的简称，用于描述对象的共同属性和方法。在C++中，类可以使用 <code>struct</code> 、<code>class</code> 或者 <code>union</code> 来定义。其中，类的属性用数据成员表示，类的方法用函数成员来表示。类的成员可以使用保留字 <code>private</code> 、<code>public</code> 或者 <code>protected</code> 来标识访问权限。</p>\n<p>​    对象是类的实例，也就是某个类的值，它可以是一个变量，也可以是一个常量。类是一种__数据结构__，而对象代表了一段__内存__，存储了数据结构的值。当产生一个对象时，必须调用__构造函数__初始化对象；当一个对象“死亡”时，则需要调用__析构函数__释放对象占用的资源。</p>\n<h3 id=\"关于访问控制\"><a href=\"#关于访问控制\" class=\"headerlink\" title=\"关于访问控制\"></a>关于访问控制</h3><p>​    关键字<code>private</code> 、<code>public</code> 和 <code>protected</code>描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但<u>只能通过公有成员函数 (或者友元函数) 来访问对象的私有成员</u>。</p>\n<p>​    <code>private</code> 成员仅供<strong>同一类</strong>的成员函数访问；<code>protected</code> 成员仅供所在类及派生类的成员函数访问；<code>public</code> 成员可供任何成员或非成员函数访问。</p>\n<p>​    无论类的数据成员还是成员函数，都可以在类的公有部分或者私有部分中声明它。通常把数据成员放在私有部分，组成类接口的成员函数放在公有部分。</p>\n<p>​    不必在<strong>class类</strong>声明中使用关键字 <code>private</code> ，因为这是它的默认访问控制(注：struct和union定义的类成员默认访问权限为 <code>public</code>)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">world</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> mass;\t\t<span class=\"comment\">//默认是私有的</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">20</span>]\t<span class=\"comment\">//私有</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>​    构造函数是类封装的特殊的实例函数成员，用于对对象的数据成员进行初始化，<u>对象必须初始化且仅能初始化一次</u>。 <strong>默认构造函数</strong>不能被显式调用。 </p>\n<p>​    构造函数为对象申请各种资源用于初始化。除了隐含参数 <code>this</code> 外，构造函数还可以自带若干参数。</p>\n<p>​    构造函数与类名同名。</p>\n<p>​    <strong>需要注意的是</strong>，如果没有提供任何构造函数，则C++会自动提供<strong>默认构造函数</strong>，它不会做任何工作。对于某个类，如Stock类，默认构造函数可能如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stock::<span class=\"built_in\">Stock</span>() &#123;...&#125;\t<span class=\"comment\">//参数表无参</span></span><br></pre></td></tr></table></figure>\n\n<p>​    并且，<strong>当且仅当</strong>没有定义任何构造函数时，编译器才会提供默认构造函数。也就是说，为类定义了构造函数之后，程序员还必须为类提供默认构造函数。如果在定义前者之后未定义后者，以下声明将出错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stock stock1;</span><br></pre></td></tr></table></figure>\n\n<p>​    通常用户定义的默认构造函数应可以给给所有成员提供隐式初始值。</p>\n<p>​    构造函数既可以用于类的初始化，也可以用来给类赋新值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stock stock2 = <span class=\"built_in\">Stock</span>(<span class=\"string\">&quot;Boffo Objects&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">2.0</span>);\t<span class=\"comment\">//这里是初始化，可能会创建新的临时对象（看编译器）用于赋值</span></span><br><span class=\"line\">stock1 = <span class=\"built_in\">Stock</span>(<span class=\"string\">&quot;Niftty Foods&quot;</span>, <span class=\"number\">10</span>, <span class=\"number\">50.0</span>);\t<span class=\"comment\">//这里是赋值而不是初始化，实际上创建了一个新的对象，然后将其内容复制给stock1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>​    析构函数也是类封装的特殊的实例函数成员，其特点是和类名同名且名前带有<strong>“ ~ ”</strong>，同时，无论是程序自定义还是C++默认生成的析构函数，都只能有一个隐含参数 <code>this</code> 。  析构函数可以被显式调用。</p>\n<p>​    析构函数用于对数据成员申请的资源进行回收，如果构造函数为类成员动态分配了内存（如<strong>new</strong>），则析构函数相应地要释放这些内存（<strong>delete</strong>）。与构造函数不同，析构函数可以执行多次，但是应当尽量避免资源被多次释放。</p>\n<p>​    构造函数和析构函数都不可以定义返回类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">STRING</span>\t\t\t\t//定义了一个名为<span class=\"title\">STRING</span>的类</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span>* CHARPTR;\t<span class=\"comment\">//定义类型成员</span></span><br><span class=\"line\">    CHARPTR s;\t\t\t\t<span class=\"comment\">//定义数据成员</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strlen</span><span class=\"params\">()</span></span>;\t\t\t<span class=\"comment\">//定义函数成员</span></span><br><span class=\"line\">    <span class=\"built_in\">STRING</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*);\t<span class=\"comment\">//定义构造函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">STRING</span>();\t\t\t\t<span class=\"comment\">//定义析构函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">STRING <span class=\"title\">y</span><span class=\"params\">(<span class=\"string\">&quot;complex&quot;</span>)</span></span>;\t<span class=\"comment\">//自动调用构造函数STRING(&quot;complex&quot;)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"C-11-列表初始化\"><a href=\"#C-11-列表初始化\" class=\"headerlink\" title=\"C++11 列表初始化\"></a>C++11 列表初始化</h3><p>​    在<strong>C++11</strong>中，可以将列表初始化语法应用于类，只要提供与某个构造函数的参数列表匹配的内容即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stock hot_tip = &#123;<span class=\"string\">&quot;...&quot;</span>, <span class=\"number\">100</span>, <span class=\"number\">45.0</span>&#125;;\t<span class=\"comment\">//可与构造函数Stock(const string &amp;co, long n = 0, double pr = 0.0)匹配</span></span><br><span class=\"line\">Stock temp = &#123;&#125;;\t<span class=\"comment\">//可与无参的默认构造函数Stock()匹配</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"const成员函数\"><a href=\"#const成员函数\" class=\"headerlink\" title=\"const成员函数\"></a>const成员函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Stock land = <span class=\"built_in\">Stock</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">land.<span class=\"built_in\">show</span>();\t<span class=\"comment\">//假设show()是Stock的成员函数</span></span><br></pre></td></tr></table></figure>\n\n<p>​    假如有如上代码片段，对于当前的C++，编译器会拒绝第二行。因为show()的代码可能不能保证调用对象不被修改——调用对象就跟const一样不应被修改。对于没有任何参数的成员函数，我们并不能通过将函数参数声明为const引用或指向const的指针来解决问题。这里的解决方法是将const关键字加到函数的括号后面，即相关函数的定义和声明应如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;\t<span class=\"comment\">//保证函数不修改对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Stock::show</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>​    以这种方式声明和定义的类函数被称为<strong>const成员函数</strong>。</p>\n","categories":["学习"],"tags":["C++"]},{"title":"(转载)人文摄影中如何拍摄陌生人","url":"/2021/11/26/%E4%BA%BA%E6%96%87%E6%91%84%E5%BD%B1%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8B%8D%E6%91%84%E9%99%8C%E7%94%9F%E4%BA%BA/","content":"<p><a href=\"https://imgtu.com/i/oZsYVA\"><img src=\"https://z3.ax1x.com/2021/11/26/oZsYVA.jpg\" alt=\"oZsYVA.jpg\" border=\"0\"/></a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>人文摄影每个人的定义都不同，我觉得本质就是关注人的生活状态的摄影活动。通常人文照片当中除了人（主体）以外，还会有背景、线条、符号等引出照片的故事（氛围），这五点称为照片的五要素。这里就不展开了 ，只简单介绍下我自己拍摄人文照片的三个拍摄陌生人的方法和拍摄方法。</p>\n</blockquote>\n<p>(本文经授权转载自酷安用户 @<strong>Atmogz</strong> 图文 《人文摄影中如何拍摄陌生人》)</p>\n<span id=\"more\"></span>\n\n<h3 id=\"人像照与人文照\"><a href=\"#人像照与人文照\" class=\"headerlink\" title=\"人像照与人文照\"></a>人像照与人文照</h3><p>陌生人的人像照（指还是能交待环境，不是过度虚化的人文类人像照）与人文照有相同点，也有很大的不同点，先对比下人像照片和人文照片有什么区别。 </p>\n<a href=\"https://imgtu.com/i/oZyMon\">\n\n<img src=\"https://z3.ax1x.com/2021/11/26/oZyMon.jpg\" alt=\"oZyMon.jpg\" border=\"0\"  width=\"500\" height=\"332\" align=\"center\"/>\n\n</a>\n\n<p>人像照片通常我们需要通过构图或虚化来尽量避开杂乱的背景。看下图可知道我是蹲下从下向上拍摄，避开周围的杂乱背景，通过<strong>90mm左右</strong>的焦段压缩感，让3个小朋友更显亲密，光圈通常我只用<strong>f8或更小</strong>，不会过度虚化背景。 </p>\n<a href=\"https://imgtu.com/i/oZcta9\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZcta9.jpg\" alt=\"oZcta9.jpg\" border=\"0\" border=\"0\"  width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>这张同行伙伴所拍的就是典型的人文照片，<strong>主体</strong>（拍摄者与被拍摄者），<strong>背景</strong>（屋顶倒塌的房子与救灾帐篷，反映出拍摄地点是在地震过后的人们生活区），<strong>符号</strong>（背景当中的人与小卖部，反映出生活区中人们的生活状况），这几个要素反映了出这张照片要说的故事。</p>\n<p>通过上面两张照片，知道人像照是要<u>突出人物，尽量减少背景中的干扰</u>，当然也可用拍人文的方法拍摄人像照，以交代被拍摄人物的生活或工作场景。而人文照是通过照片中的人和背景以及当中的符号 来讲故事的。可以简单理解为写叙述文那要，要有人物、地点、时间（当然照片反映不出时间），用以反映发生了什么故事。</p>\n<h3 id=\"人文摄影方式\"><a href=\"#人文摄影方式\" class=\"headerlink\" title=\"人文摄影方式\"></a>人文摄影方式</h3><p>人文摄影拍摄人物一般有：<strong>沟通</strong>、<strong>等待</strong>、<strong>抓拍</strong>三种方式。</p>\n<h4 id=\"沟通\"><a href=\"#沟通\" class=\"headerlink\" title=\"沟通\"></a>沟通</h4><p>沟通并不是生硬地突然去问被拍摄者愿不愿意被拍，而是应该有前期铺垫，先和人物聊会天，一般围绕我们想拍的环境或事物展开就行。沟通后被拍摄者往往不会介意被拍，有的还更加配合。</p>\n<p>其实人文摄影在拍摄前应该多去和当地人沟通（找间老店或坐树头的老人家，如杂货店），了解当下环境的过往，最好是有什么故事，这样对拍摄会更有帮助（比如可以根据故事去拍摄，拍摄后写照片介绍也更有趣）。 </p>\n<a href=\"https://imgtu.com/i/oZgARx\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZgARx.jpg\" alt=\"oZgARx.jpg\" border=\"0\"  width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>这组照片我要拍摄的主体是这间一看就很有历史的理发店，人物反而是符号。人文照片的构图我会尽量简少透视感的干扰，用比较平稳的构图减少观看者对画面外的猜想，以突出画面内容。 </p>\n<a href=\"https://imgtu.com/i/oZgawQ\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZgawQ.jpg\" alt=\"oZgawQ.jpg\"  border=\"0\"  width=\"500\" height=\"337\" align=\"center\"/>\n\n</a>\n\n<p>沟通后就能慢慢拍摄，可以用不同构图多拍几张去挑选。像这张贴着橱窗拍摄时，抬起镜头让部分玻璃的反射物也拍摄到，让观看者知道是隔着玻璃拍摄的。 </p>\n<a href=\"https://imgtu.com/i/oZgdoj\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZgdoj.jpg\" alt=\"oZgdoj.jpg\" border=\"0\" width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>和理发店里面的老人家沟通内容是围绕这间店的历史，比如没入镜有60多年历史的吊扇和这张解放前就有的理发椅。这张椅子也就成为了这张照片的主体，理发师（据说是第三代了）和顾客只是这店的符号。符号可以理解为反映主体所在地或主体在做什么的事物，如上面帐篷区的小卖部与人们、拿剪发剪的理发师、戴着厨师帽的厨师等…… </p>\n<a href=\"https://imgtu.com/i/oZ2ucV\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2ucV.jpg\" alt=\"oZ2ucV.jpg\" border=\"0\" width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>要拍某些人物，可从他们所做的事情开始聊起。像这两张人像照，我是先和同行的小朋友说老人家做的竹艺不错，而且单用一把竹刀就行，要有几十年功力才能做到（吹捧手艺或工作）。接着才和老人家聊天，一面聊一面拍照，老人家兴奋起来还点上烟来上几张。这两张照片主要表达的是老人家的手艺，所以就没过多去拍环境，只保留背景中的竹林。 </p>\n<a href=\"https://imgtu.com/i/oZ2Ekj\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2Ekj.jpg\" alt=\"oZ2Ekj.jpg\" border=\"0\" width=\"281\" height=\"500\" align=\"center\"/>\n\n</a>\n\n<p>有时候有想拍场景与人物，但没有能切入沟通的点，也是只能直接询问被拍人物，征得同议后再拍。当我发现这电线杆有免费充电口后，每天会故意经过这里，想拍下有人在充电的照片（以反映有人在使用城市免费提供的便利设施场景）。三天里不是没人，就是流浪者在这充电，我都是上前直接询问能否拍下他在这充电的场景，前两个流浪者都很抗据就没有拍照直接走人，问到第三个流浪者才同意让我拍摄。照片使用了手机的超广角进行拍摄，让视觉冲击更强。（一般情况下人文照我有三不拍：流浪者不拍，残疾人不拍，争吵打架不拍。这三类人心理相对比较敏感，为了自身和器材的安全……）</p>\n<h4 id=\"等待\"><a href=\"#等待\" class=\"headerlink\" title=\"等待\"></a>等待</h4><p>偶尔发现一个不错的场景想拍，又不想和路人有沟通，可以举着相机对着想拍的场景，动作幅度要大点，显得很大方的样子。等待路人或拍摄的人物进入，构图合适才按下快门。这个是解决拍摄陌生人尴尬，和怕别人不愿意被拍的好方法。</p>\n<p>大大方方举着相机，路人经过一般能看到我们，就不会觉得我们是在故意拍他们（这也是一种前期铺垫），不愿意被拍的一般会躲开，没所谓或没留意的就会走入画面。哪怕路人被拍摄后才发觉而有意见，也不会有太大反应，即时删掉照片再举起相机就行。 </p>\n<a href=\"https://imgtu.com/i/oZ2Vts\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2Vts.jpg\" alt=\"oZ2Vts.jpg\" border=\"0\" width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>这个场景拍摄了不少于三分钟，拍摄了十几张后才挑选出这张对于街头表演不同有反应的路人照。 </p>\n<a href=\"https://imgtu.com/i/oZ2QnU\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2QnU.jpg\" alt=\"oZ2QnU.jpg\" border=\"0\" width=\"375\" height=\"500\" align=\"center\" />\n\n</a>\n\n<p>这张举着手机等远处的小朋友走近后才按快门，近处小朋友的妈妈还主动让开，过来看着我的手机画面。</p>\n<h4 id=\"抓拍\"><a href=\"#抓拍\" class=\"headerlink\" title=\"抓拍\"></a>抓拍</h4><p>这方法就不举例了。</p>\n<p>最后聊聊拍摄人文照所用的镜头焦段，我个人比较喜欢用28mm、35mm、50mm这三个焦段，只有当距离拍摄场景太远，而且跑不过去的情况下才会用更长的焦段。</p>\n<p>原因有：</p>\n<ol>\n<li>广角到标镜范围能近距离拍到更大的场景</li>\n<li>方便与被拍摄人物的交流</li>\n<li>更容易观察到被拍摄者的表情以及眼神光</li>\n<li>光线不好的时候，被拍摄者能反射更多的光线</li>\n<li>减轻环境中其它的光线干扰，特别是室内环境</li>\n</ol>\n<p>下面用两张在自然光下，拍摄人文类人像照典型的用光方式的照片举例说明。 </p>\n<a href=\"https://imgtu.com/i/oZ2k7Q\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2k7Q.jpg\" alt=\"oZ2k7Q.jpg\" border=\"0\" width=\"500\" height=\"333\" align=\"center\"/>\n\n</a>\n\n<p>让人物在室内（或树荫下），面向室外（门口或窗户），柔和的自然光（面积光）会减少人物的阴影，让人物皮肤更显柔和（适合拍女性人像），也容易形成漂亮的眼神光，缺点就是人物的立体感不强。在这样弱光环境下，最好是用28mm-50mm焦段拍摄，用长焦的话就需要更大的光圈拍摄才行，大光圈就容易过度虚化背景，也就丢失了背景环境。 </p>\n<a href=\"https://imgtu.com/i/oZ2Zhn\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2Zhn.jpg\" alt=\"oZ2Zhn.jpg\" border=\"0\" width=\"500\" height=\"333\" align=\"center\"/>\n\n</a>\n\n<p>另一种方式是让人物在室内（或树荫下），侧面对着户外。侧光会让人物的更具立体感，缺点就是明暗对比会过强，皮肤不够柔和（适合拍中老年人，更显沧桑），难以形成漂亮的眼神光。在这类光照场景中，为了让暗部细节不会丢失过多，就需要更加靠近被拍人物拍摄。28mm-50mm焦段自然就是理想焦段了，和上面一样用长焦拍摄的话就需要更大光圈，会丢失背景环境。</p>\n<p>另外还有一个很少摄影教材会写的在自然光下用28mm-50mm拍摄的好处。 </p>\n<a href=\"https://imgtu.com/i/oZ2KXT\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2KXT.jpg\" alt=\"oZ2KXT.jpg\" border=\"0\" width=\"500\" height=\"333\" align=\"center\"/>\n\n</a>\n\n<p>在午间强烈的阳光下，我们可以让被拍摄者背向太阳，稍微低头避免脸上的明暗对比过强。但没有闪光灯或反光板补光，人物的脸就容易过暗。这时候靠近拍摄，摄影师衣服的反光也能作为补光（特别是穿白色衣服），留意照片中小朋友的眼神光不是天空形成，而是我身上的白T恤反射形成。 </p>\n<a href=\"https://imgtu.com/i/oZ2n10\">\n\n<img src=\"https://z3.ax1x.com/2021/11/27/oZ2n10.jpg\" alt=\"oZ2n10.jpg\" border=\"0\" width=\"500\" height=\"375\" align=\"center\"/>\n\n</a>\n\n<p>同样是午间拍摄的小女孩，眼神光是由蔬菜反射光形成的，自然也给小女孩的脸补光了。</p>\n<p>有没发现眼神光是能让人文类人像照感动观看者的利器，这也是为什么说28mm-50mm是人文摄影师常用的焦段，还有大多人像照只拍摄半身甚至胸部以上的原因。</p>\n<p>希望这几个人文摄影的小技巧对大家拍摄人文照有所帮助。</p>\n","categories":["随笔"],"tags":["日常"]},{"title":"马++参考书摘抄：多态与虚函数","url":"/2021/11/07/%E9%A9%AC-%E5%8F%82%E8%80%83%E4%B9%A6%E6%91%98%E6%8A%84%EF%BC%9A%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/","content":"<p><del>一看就知道我是上课没有好好听课。</del></p>\n<p>内容摘抄自《C++程序设计精要教程》(编著 马光志)。</p>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"8-1虚函数\"><a href=\"#8-1虚函数\" class=\"headerlink\" title=\"8.1虚函数\"></a>8.1虚函数</h3><h4 id=\"8-1-1-虚函数的声明和定义\"><a href=\"#8-1-1-虚函数的声明和定义\" class=\"headerlink\" title=\"8.1.1 虚函数的声明和定义\"></a>8.1.1 虚函数的声明和定义</h4><p>重载函数是一种静态多态函数， 虚函数是一种动态多态函数。 </p>\n<p>当派生类中含有与基类虚函数同名的实例成员函数，其显式参数类型都应相同；当基类虚函数返回类型为基类指针p或者引用r时，派生类同名函数成员返回类型必须为可向p或者r赋值的基类/派生类指针(或引用)，其他情况两者的返回类型必须相同。</p>\n<p><strong>C++中不允许将构造函数定义为虚函数或者纯虚函数。</strong></p>\n<p>当基类中包含基类指针或者引用时，应将其析构函数定义为虚函数，所以一般可以将析构函数定义为虚函数。最好也将类的所有实例成员函数定义为虚函数。</p>\n<p>当基类和派生类都定义了原型”相容”的虚函数时，如果基类指针指向的是派生类对象，则通过基类指针调用的是派生类的函数成员，否则调用基类的函数成员(基类引用引用了派生类对象同理)。</p>\n<p>不能用<code>virtual</code>修饰类的友元函数，虚函数也不能定义为<code>constexpr</code>函数。</p>\n<h4 id=\"8-1-2-虚函数的重载和内联\"><a href=\"#8-1-2-虚函数的重载和内联\" class=\"headerlink\" title=\"8.1.2 虚函数的重载和内联\"></a>8.1.2 虚函数的重载和内联</h4><p>基类与派生类定义的同名虚函数的访问权限可以不同。在C++的同一个类中，不能定义显式参数表(类型)完全相同、仅返回类型不同的静态成员函数或实例成员函数。    <strong>基类虚函数的特性会一直继承</strong>。</p>\n<p>基类指针指向派生类对象时，调用成员函数时优先调用离该派生类最近的实例成员函数，若在该对象继承的类中都找不到所找函数时，才会调用基类对应的成员函数。若想限定使用某一级中的成员函数，可以用类名加作用域运算符 <strong>“::”</strong> 进行限定。\n　　</p>\n<h5 id=\"关于内联inline\"><a href=\"#关于内联inline\" class=\"headerlink\" title=\"关于内联inline\"></a>关于内联inline</h5><p>虚函数可以申明为<code>inline</code>，具体到编译器解释时候，如果编译器在编译的时候就可以确定该虚函数的决议，则编译器以<code>inline</code>方式静态决议该虚函数。如果编译器在编译的时候不能决定，则必须在运行时决议虚函数，此时虚函数不能以<code>inline</code>函数的方式调用。</p>\n<h5 id=\"关于友元friend和virtual、static\"><a href=\"#关于友元friend和virtual、static\" class=\"headerlink\" title=\"关于友元friend和virtual、static\"></a>关于友元friend和virtual、static</h5><p>因为<code>friend</code>声明的函数不是宿主类的函数成员，所以不能和<code>virtual</code>一起使用，除非被定义的函数已经是另一个类的虚函数成员；<code>friend</code>一般也不能跟<code>static</code>一起使用，除非<code>static</code>定义的函数是文件作用域内的静态函数或者其他类定义的静态函数。</p>\n<p><code>virtual</code>一定不能与<code>static</code>一起使用，因为<code>static</code>定义的任何函数都不含隐含参数this，<code>virtual</code>则恰好相反。</p>\n<h3 id=\"8-2-虚析构函数\"><a href=\"#8-2-虚析构函数\" class=\"headerlink\" title=\"8.2 虚析构函数\"></a>8.2 虚析构函数</h3><p>如果为基类和派生类的对象分配了动态内存，或者为派生类对象的成员分配了动态内存，在一定要将基类喝派生类的析构函数定义为虚函数，否则极有可能造成内存泄漏。</p>\n<h3 id=\"8-3-类的引用\"><a href=\"#8-3-类的引用\" class=\"headerlink\" title=\"8.3 类的引用\"></a>8.3 类的引用</h3><p>引用变量是被引用实体的别名，被引用的对象应该自己负责构造和析构。</p>\n<h4 id=\"8-3-1-类的引用变量及其析构\"><a href=\"#8-3-1-类的引用变量及其析构\" class=\"headerlink\" title=\"8.3.1 类的引用变量及其析构\"></a>8.3.1 类的引用变量及其析构</h4><p>如果类A的引用变量r引用了通过<strong>new</strong>生成的对象x，而在退出r的作用域之前没将x传到作用域之外(转移)，也没有主动去析构x和释放对象x所占用的内存，那么就应该用<code>delete &amp;r</code>析构x并释放他占用的内存(注意<code>r.~A()</code>仅用于析构x，而不能释放x占用的内存，从而造成内存泄露)。</p>\n<p>当然，如果有址引用变量引用的对象不是通过<strong>new</strong>产生的，则引用变量无需负责对被引用的对象进行析构。</p>\n<p>无址引用变量引用的是对象常量，由于移动语义的引入，被无址引用的常量对象的析构将推迟到该引用变量生命期的结束。所以虽然无址引用变量不负责常量对象的析构，但被其引用的常量对象的析构确实与变量的生命期有关。</p>\n<h4 id=\"8-3-2-类的引用参数及其结构\"><a href=\"#8-3-2-类的引用参数及其结构\" class=\"headerlink\" title=\"8.3.2 类的引用参数及其结构\"></a>8.3.2 类的引用参数及其结构</h4><p>对形参不是引用类型而是对于一般对象类型来说，形参相当于局限于当前函数的局部变量。这种形参对象的构造是在调用时通过值参传递完成的，其析构则是在函数调用返回时完成的。    如果类定义了拷贝构造函数，将调用对应的拷贝函数完成。值参传递将实参对象数据成员的值相应地赋给形参对象的数据成员，而指针类型的数据成员只<strong>浅拷贝</strong>给形参对应指针成员。<br>所以一般要给类提供自定义的深拷贝构造函数以及移动构造函数。其中，移动构造函数通常实现为浅拷贝构造函数。</p>\n<h3 id=\"8-4-抽象类\"><a href=\"#8-4-抽象类\" class=\"headerlink\" title=\"8.4 抽象类\"></a>8.4 抽象类</h3><h4 id=\"8-4-1-抽象类的定义\"><a href=\"#8-4-1-抽象类的定义\" class=\"headerlink\" title=\"8.4.1 抽象类的定义\"></a>8.4.1 抽象类的定义</h4><h5 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h5><p>纯虚函数是不必定义函数体的特殊虚函数，在定义虚函数时，在其后面添加 “=0” 表示其为纯虚函数。其他特性与一般虚函数区别不大。</p>\n<h5 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h5><p>含有纯虚函数的类就是抽象类，抽象类通常作为派生类的基类。如果派生类继承了抽象类的纯虚函数，又未定义原型”相容”且带函数体的虚函数；或者派生类又定义了新的纯虚函数，则当前的派生类还是抽象类。直到派生类中有一个类给所有继承来的纯虚函数定义了具体的函数体，该派生类才能成为非抽象类。<br>只有非抽象类才能产生对象。抽象类不能定义或产生任何对象，包括使用<strong>new</strong>创建对象、定义对象数组等等。不过，抽象类可以作为<strong>父类引用或者指针</strong>，用于引用或者指向子类中的具体对象。<br>抽象类指针或引用可以调用抽象类的纯虚函数，此时调用的一定是子类中关于该函数的具体实现(虚函数)。</p>\n<h3 id=\"8-5-虚函数友元与晚期绑定\"><a href=\"#8-5-虚函数友元与晚期绑定\" class=\"headerlink\" title=\"8.5 虚函数友元与晚期绑定\"></a>8.5 虚函数友元与晚期绑定</h3><p>纯虚函数与一般虚函数一样，可以作为其他类的友元函数。不过一般不会将这种未定义函数体的函数作为友元。</p>\n<h4 id=\"8-5-1-虚函数作为友元\"><a href=\"#8-5-1-虚函数作为友元\" class=\"headerlink\" title=\"8.5.1 虚函数作为友元\"></a>8.5.1 虚函数作为友元</h4><p>友元关系不能被传递或者继承。例如，类A的成员函数f( )是类B的友元，f( )可以访问B中所有成员，但是f()不能访问类B的派生类对象中的所有成员(除非f()也是其派生类的友元)。<br>同理，友元特性不能被继承关系传递，如A的函数<code>void f1(C &amp;)</code>作为友元，可以访问C类对象中的所有成员，但是A的派生类B中的<code>void B::f1(C &amp;)</code>不能访问类C的私有和保护成员。</p>\n<h4 id=\"8-5-2-虚函数的晚期绑定\"><a href=\"#8-5-2-虚函数的晚期绑定\" class=\"headerlink\" title=\"8.5.2 虚函数的晚期绑定\"></a>8.5.2 虚函数的晚期绑定</h4><p> 举例说明，假定基类B及其派生类D都定义了虚函数，BD将分别产生虚函数地址表TB和TD。在构造D类对象d时，先将d作为基类B对象构造，故将TB首地址存放到d的起始单元，此时<code>B::B()</code>调用的虚函数将和TB中的虚函数绑定；当<code>B::B()</code>构造完毕，在执行D类构造函数<code>D::D()</code>之前，会将TD的首地址放到d的起始单元，此后<code>D::D()</code>调用的虚函数就会与TD中的虚函数进行绑定，即晚期绑定。<br>d析构的时候绑定顺序与构造时相反。这也说明子类对象的类型并不是固定的，在构造或者析构的某些时刻，子类对象可以被看作父类对象。</p>\n<h3 id=\"8-6-有虚函数时的内存布局\"><a href=\"#8-6-有虚函数时的内存布局\" class=\"headerlink\" title=\"8.6 有虚函数时的内存布局\"></a>8.6 有虚函数时的内存布局</h3><h5 id=\"基类有虚函数时的内存布局\"><a href=\"#基类有虚函数时的内存布局\" class=\"headerlink\" title=\"基类有虚函数时的内存布局\"></a>基类有虚函数时的内存布局</h5><p>如果基类定义了虚函数或者纯虚函数，则派生类对象将共享基类对象的起始单元(存储单元)，用于存放虚函数地址表首址。</p>\n<h5 id=\"基类无虚函数时的内存布局\"><a href=\"#基类无虚函数时的内存布局\" class=\"headerlink\" title=\"基类无虚函数时的内存布局\"></a>基类无虚函数时的内存布局</h5><p>如果基类没有定义虚函数，其单继承派生类定义了虚函数，则派生类的内存由三个部分组成：首先是继承自基类的内存，然后是派生类虚函数地址表首址，然后是该派生类中定义的实例数据成员。</p>\n","categories":["学习"],"tags":["C++"]},{"title":"Java - 类与对象(二)","url":"/2022/01/26/Java-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1(%E4%BA%8C)/","content":"<p>接上文</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>参考资料</p>\n<p>《Java核心技术  卷1(第十一版)》 </p>\n<p>《Java基础核心总结》 </p>\n<p><a href=\"https://www.runoob.com/java/java-tutorial.html\">菜鸟教程</a></p>\n</blockquote>\n<hr>\n<h2 id=\"非访问修饰符\"><a href=\"#非访问修饰符\" class=\"headerlink\" title=\"非访问修饰符\"></a>非访问修饰符</h2><h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>final修饰符用于修饰变量、方法和类。</p>\n<h4 id=\"final变量\"><a href=\"#final变量\" class=\"headerlink\" title=\"final变量\"></a>final变量</h4><p>被final修饰的变量只能被赋值一次；被final修饰的实例成员必须显式指定初始值(可以在类声明或者构造函数中指定)；final常与static一起用于声明类常量，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> X = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"final方法\"><a href=\"#final方法\" class=\"headerlink\" title=\"final方法\"></a>final方法</h4><p>父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是防止该方法的内容被修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">A</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"final类\"><a href=\"#final类\" class=\"headerlink\" title=\"final类\"></a>final类</h4><p>final类不能被其他类继承。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>final修饰符适用于基本数据类型或者<strong>不可变类</strong>(包含的所有类方法都不会改变其对象的类，比如String类)；对于可变的类，使用final修饰符可能引起混乱。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringBuilder e;\t<span class=\"comment\">//此处的对象变量e类似于C++中的const指针，指向的对象是唯一的，但是对象本身的内容可以改变</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><p>static修饰符用于修饰类方法和类变量。</p>\n<h4 id=\"静态变量\"><a href=\"#静态变量\" class=\"headerlink\" title=\"静态变量\"></a>静态变量</h4><p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝，拷贝由此类所有实例共享。静态变量也被称为类变量/类字段。局部变量不能被声明为 static 变量。</p>\n<h4 id=\"静态常量\"><a href=\"#静态常量\" class=\"headerlink\" title=\"静态常量\"></a>静态常量</h4><p>static和final一起使用用于修饰静态常量，由于其不可更改，所以公共常量也比较常见，比如Math类中的圆周率PI和输出流System.out。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Math</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> PI = <span class=\"number\">3.14159265358979323846</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h4><p>与C++相同，类静态方法没有this参数，所以也<u>不能访问非静态的实例变量成员，但是可以访问静态变量</u>。静态方法可以使用 <code>类名.xxx</code> 或 <code>实例名.xxx</code> 进行调用。工厂方法(工厂模式)是静态方法的应用之一。</p>\n<p>main方法也是典型的静态方法。main方法也不对任何对象进行操作，但是在程序启动时会执行并构造程序所需要的对象；每个类都可以由一个main方法，通过执行 <code>java ClassName</code> 可以运行不同类的main方法。</p>\n<hr>\n<h3 id=\"abstract\"><a href=\"#abstract\" class=\"headerlink\" title=\"abstract\"></a>abstract</h3><p>abstract 修饰符用于创建抽象类和抽象方法。</p>\n<hr>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>volatile修饰符可用于修饰变量。主要用于线程的编程。</p>\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><p>synchronized修饰符用于修饰方法。主要用于线程的编程。</p>\n<h3 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h3><p>transient用于修饰变量。</p>\n<hr>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>Java允许 <strong>包 (package)</strong> 将类组织在一个集合中。使用包的主要原因是确保类名的唯一性(通过增加限定的包名)。</p>\n<p>包的作用有</p>\n<ul>\n<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>\n<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>\n<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>\n</ul>\n<h3 id=\"类的导入\"><a href=\"#类的导入\" class=\"headerlink\" title=\"类的导入\"></a>类的导入</h3><p>一个类可以使用其所属包中的任何类，以及其他包中的公共类。</p>\n<p>类的访问方式有以下几种</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用完全限定名：直接在包名后面跟上类名</span></span><br><span class=\"line\">java.time.LocalDate today = java.time.LocalDate.now();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//import某个包中所有类</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//import某个特定类</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDate;</span><br></pre></td></tr></table></figure>\n\n<p>星号 “*” 只能导入一个包，比如不能使用 <code>import java.*</code>导入以java为前缀的所有包。</p>\n<p>有时候使用星号进行省略时，可能会出现命名冲突。例如，<code>java.util</code> 和 <code>java.sql</code> 包中都有Date类，如果程序导入了这两个包且使用了Date类的话，编译器会报错。此时建议明确写出要使用哪个包里的Date类，如 <code>import java.util.Date;</code>。</p>\n<blockquote>\n<h4 id=\"include-和-import的区别\"><a href=\"#include-和-import的区别\" class=\"headerlink\" title=\"#include 和 import的区别\"></a>#include 和 import的区别</h4></blockquote>\n<h3 id=\"在包中增加类\"><a href=\"#在包中增加类\" class=\"headerlink\" title=\"在包中增加类\"></a>在包中增加类</h3><h3 id=\"包的访问\"><a href=\"#包的访问\" class=\"headerlink\" title=\"包的访问\"></a>包的访问</h3><h3 id=\"类路径\"><a href=\"#类路径\" class=\"headerlink\" title=\"类路径\"></a>类路径</h3>","categories":["学习"],"tags":["Java"]},{"title":"Java - 类与对象(一)","url":"/2022/01/23/Java-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1(%E4%B8%80)/","content":"<p><em><strong>Core Java</strong></em> 也是厚得不行……</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>参考资料</p>\n<p>《Java核心技术  卷1(第十一版)》 </p>\n<p>《Java基础核心总结》 </p>\n<p><a href=\"https://www.runoob.com/java/java-tutorial.html\">菜鸟教程</a></p>\n</blockquote>\n<hr>\n<h2 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h2><h3 id=\"对象变量与对象\"><a href=\"#对象变量与对象\" class=\"headerlink\" title=\"对象变量与对象\"></a>对象变量与对象</h3><p>对象变量并没有实际包含一个对象，而只是引用一个对象。</p>\n<p>在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的<strong>引用</strong>，<code>new</code>操作符的返回值也是一个引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Date deadline = <span class=\"keyword\">new</span> Date();</span><br></pre></td></tr></table></figure>\n\n<p>上述语句包含两个部分，<code>new Date()</code>构造了一个Date类型的对象，该表达式的返回值是对这个新创建对象的引用，这个引用存储在变量deadline中。</p>\n<p>可以显式地将对象变量设置为<code>null</code>表示不引用任何对象。</p>\n<p>可以把Java中的对象变量看作类似于C++中的<strong>对象指针</strong>。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>类最基本的要素是属性和方法。属性又称为<strong>字段</strong>。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><h4 id=\"方法参数\"><a href=\"#方法参数\" class=\"headerlink\" title=\"方法参数\"></a>方法参数</h4><p>程序设计语言中，将参数传递给方法(或函数)的方式主要有<strong>按值调用</strong>和<strong>按引用调用</strong>两种。</p>\n<p>Java总是采用按值调用(无论是对基本类型还是对象，或者说，<strong>对象引用是按值传递的</strong>)。</p>\n<p>方法能对参数进行的操作：</p>\n<ul>\n<li>方法不能修改基本数据类型的参数(int, double, boolean,…, 因为没有引用参数&amp;)</li>\n<li>方法可以改变对象的<strong>状态</strong></li>\n<li>方法不能改变对象参数的引用情况(不能让一个对象参数引用一个新的对象)</li>\n</ul>\n<h4 id=\"更改器方法和访问器方法\"><a href=\"#更改器方法和访问器方法\" class=\"headerlink\" title=\"更改器方法和访问器方法\"></a>更改器方法和访问器方法</h4><p>可以理解为C++中的一般的成员方法和const成员方法。在Java语言中，两者在语法上没有明显区别。</p>\n<hr>\n<h2 id=\"类的声明和定义\"><a href=\"#类的声明和定义\" class=\"headerlink\" title=\"类的声明和定义\"></a>类的声明和定义</h2><h3 id=\"构造器方法-构造函数\"><a href=\"#构造器方法-构造函数\" class=\"headerlink\" title=\"构造器方法/构造函数\"></a>构造器方法/构造函数</h3><p>类似C++中类的构造函数，构造器与类同名。不能对已经存在的对象重复调用构造器。</p>\n<p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认的无参构造方法。如果你已经定义了别的构造方法，JVM就不再提供这个默认构造器(与C++类似)。</p>\n<p>默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。</p>\n<p>构造器的特点(除了最后一个，其他跟C++构造函数没啥区别)：</p>\n<ul>\n<li>与类同名</li>\n<li>构造器可以有多个，构造器的参数也可以有多个</li>\n<li>构造器没有返回值和参数类型</li>\n<li>所有的Java对象都在堆中构造，构造器总是搭配 <code>new</code> 运算符来调用</li>\n</ul>\n<h3 id=\"类方法的定义\"><a href=\"#类方法的定义\" class=\"headerlink\" title=\"类方法的定义\"></a>类方法的定义</h3><p>与C++不同，在Java中，所有的方法都必须在类的内部定义。在C++中，如果在类的内部定义方法，该方法会自动成为<strong>内联(inline)方法</strong>。Java中则不然，是否将某个方法设置为内联方法是Java虚拟机的任务。</p>\n<hr>\n<h2 id=\"方法的重载和重写\"><a href=\"#方法的重载和重写\" class=\"headerlink\" title=\"方法的重载和重写\"></a>方法的重载和重写</h2><h3 id=\"方法的重载\"><a href=\"#方法的重载\" class=\"headerlink\" title=\"方法的重载\"></a>方法的重载</h3><p>方法重载也类似于C++。Java允许重载任何方法。重载的条件包括：</p>\n<ul>\n<li>方法名称必须相同</li>\n<li>参数列表必须不同，方法返回类型、修饰符的有无和类型可相同可不相同</li>\n<li>仅仅返回类型不同不足以成为方法的重载</li>\n<li>方法的重载发生在编译时</li>\n</ul>\n<h3 id=\"方法的重写\"><a href=\"#方法的重写\" class=\"headerlink\" title=\"方法的重写\"></a>方法的重写</h3><p>方法重载的描述是同一类中的，重写是子类对父类的允许访问的方法的实现过程进行重新编写。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;类A的函数func1&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;类B的函数func1&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;类B的函数func2&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中，子类B中的 <code>func1</code> 方法是对父类A同名方法的重写。</p>\n<p>父类对象变量引用子类对象时执行被重写的方法时，执行的是子类中的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tA a = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">\t\ta.func1();\t<span class=\"comment\">//执行的是B中的func1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（好像C++……）</p>\n<p>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//\t\tSystem.out.println(&quot;类B的函数func1&quot;);</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.func1();\t<span class=\"comment\">//A::func1()</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于static修饰的方法不能使用super。</p>\n<p>重写的原则为：</p>\n<ul>\n<li>重写的方法除内容外应与父类保持一致，包括方法名称、参数列表</li>\n<li>重写的方法的返回值类型一般与父类方法相同；Java 7之后返回值类型可以不相同，但是必须是父类返回值类型的派生类</li>\n<li>父类的方法只能被子类重写</li>\n<li>子类中的重写方法访问权限不能低于父类中同名方法的访问权限</li>\n<li>声明为 <code>final</code> 或者 <code>static</code> 的方法不能被重写，但是静态方法可以被多次声明</li>\n<li><strong>构造方法不能被重写</strong></li>\n<li>重写方法不能抛出新的检查异常或者比被重写方法申明<strong>更加宽泛</strong>的异常。</li>\n<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li>\n<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li>\n</ul>\n<hr>\n<h2 id=\"类的初始化\"><a href=\"#类的初始化\" class=\"headerlink\" title=\"类的初始化\"></a>类的初始化</h2><p>除了调用对于构造方法之外，Java中可以直接在类定义中就给任何属性赋初值或者通过方法赋初值(在C++中就得依靠相应的构造函数)，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;\t\t\t\t<span class=\"comment\">//直接赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> c = assign();\t\t<span class=\"comment\">//通过方法赋值</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">assign</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<strong>final</strong>类型属性，直接在定义时初始化，或者声明后在所有构造方法中都记得赋初值就行了。</p>\n<h3 id=\"默认构造器的初始化\"><a href=\"#默认构造器的初始化\" class=\"headerlink\" title=\"默认构造器的初始化\"></a>默认构造器的初始化</h3><p>JVM提供的默认无参构造方法会把基础数据成员的值都设置为<strong>0</strong>或<strong>0.0</strong>或<strong>false</strong>，其他对象类型则会初始化为<strong>null</strong>。</p>\n<p>但是方法中的局部变量必须明确地赋初值。</p>\n<h3 id=\"静态属性的初始化\"><a href=\"#静态属性的初始化\" class=\"headerlink\" title=\"静态属性的初始化\"></a>静态属性的初始化</h3><p>静态属性可以通过直接在类定义时赋初值完成初始化。</p>\n<p>如果静态属性的初始化需要比较复杂的代码，可以使用静态的初始化块：将初始化代码放在一个块中，并标记关键字static。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//静态初始化块示例</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> nextId;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">static</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> generater = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    nextId = generater.nextInt(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在类第一次加载时，会进行静态属性的初始化。</p>\n<h3 id=\"无基类时的初始化顺序\"><a href=\"#无基类时的初始化顺序\" class=\"headerlink\" title=\"无基类时的初始化顺序\"></a>无基类时的初始化顺序</h3><p><strong>静态属性初始化→静态方法初始化→普通属性初始化→普通方法初始化→构造函数其他部分</strong>。</p>\n<hr>\n<h2 id=\"对象的销毁\"><a href=\"#对象的销毁\" class=\"headerlink\" title=\"对象的销毁\"></a>对象的销毁</h2><p>虽然Java是基于C++的，但是Java中不支持析构方法，不需要手动管理对象的<strong>销毁</strong>,当某个对象的生命周期结束时，JVM会负责其销毁。</p>\n<p>某些对象会使用内存以外的资源(比如文件)，在这种情况下，资源的及时回收和再利用显得比较重要。如果一个资源一旦使用完就需要立即关闭，那么应当提供一个 **close **方法来完成必要的清理工作。</p>\n<p>引入Java中<strong>对象作用域</strong>的概念。</p>\n<h3 id=\"对象作用域\"><a href=\"#对象作用域\" class=\"headerlink\" title=\"对象作用域\"></a>对象作用域</h3><p>作用域(scope)决定了其内部定义的变量的可见性和生命周期。一个变量的生命周期结束于其作用域(一般用 <code>&#123;&#125;</code> 决定位置)终点处。</p>\n<p>方法的参数范围涵盖整个方法，<u>参数实际上是一个局部变量</u>。</p>\n<p>循环体内声明的变量其适用范围是从它声明到循环体结束(比如for循环里面的变量)。</p>\n<p>Java不允许在嵌套的作用域中定义同名的局部变量，但是可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x = <span class=\"number\">2</span>;\t<span class=\"comment\">//C and C++ is ok</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"this和super\"><a href=\"#this和super\" class=\"headerlink\" title=\"this和super\"></a>this和super</h2><h3 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h3><p>this表示对象本身，即<strong>指向对象本身的指针</strong>。</p>\n<p><code>this.xxx</code>用来引用成员或者指向对象自己。</p>\n<p>有时候类方法的参数于与成员名字重名时，就用 <code>this.</code> 来区分。</p>\n<h3 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h3><p>super可以理解为指向<strong>离类自己继承关系最近的一个父类</strong>的指针。不过，super本质上是Java的一个关键字。</p>\n<p><code>super</code>指向当前的父类，<code>super.xxx</code>可以引用父类成员或者调用父类的方法。</p>\n<p>this和super也可以用来引用构造方法，格式为 <code>this(参数)</code> 和 <code>super(参数)</code>，分别用来调用本类中其他构造方法以及父类中的构造方法(C++里一个构造函数不能调用同类的另一个构造函数)。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><code>this(参数)</code> 和 <code>super(参数)</code>要放在构造函数的<strong>第一行</strong></li>\n<li>在一个构造函数里，这种调用方法只能使用<strong>一次</strong>，且this 和 super 不能同时出现在一个构造函数里面</li>\n<li>this() 和 super() 都指的是对象，所以均不可以在 static 环境中使用，包括static 变量、static 方法、static 语句块。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;父类无参构造函数A()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;父类构造函数A(int x)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">B</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>();\t\t\t\t<span class=\"comment\">//调用了A()</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类无参构造函数B()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">B</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(x);\t\t\t\t<span class=\"comment\">//调用了A(int x)</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类构造函数B(int x)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">B</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>(x);\t\t\t\t<span class=\"comment\">//调用了B(int x)以及包含的A(int x)</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类构造函数B(int x, int y)&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h2><p>Java中的访问控制符有<strong>default</strong>(什么也不写)、<strong>public</strong>、<strong>private</strong>、<strong>protected</strong>四种。它们都可以用来修饰类的成员，<strong>default</strong>和<strong>public</strong>还可以修饰类(包括外部类)和接口。</p>\n<h4 id=\"default\"><a href=\"#default\" class=\"headerlink\" title=\"default\"></a>default</h4><p>对同一个包内的类是可见的，变量默认为<strong>public static final</strong>，方法成员默认为<strong>public</strong>。</p>\n<h4 id=\"public\"><a href=\"#public\" class=\"headerlink\" title=\"public\"></a>public</h4><p>对于所有类都是可见的(所以main方法是public的)，类所有的公有方法和变量都能被其子类继承。</p>\n<p>如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。</p>\n<h4 id=\"private\"><a href=\"#private\" class=\"headerlink\" title=\"private\"></a>private</h4><p>类成员仅限其所属类访问。声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。</p>\n<h4 id=\"protected\"><a href=\"#protected\" class=\"headerlink\" title=\"protected\"></a>protected</h4><p>当<strong>子类与基类在同一包中</strong>时，被声明为 protected 的变量、方法和构造方法能被同一个包中的子类以及任何其他类访问；</p>\n<p>若<strong>子类与基类不在同一包中</strong>，那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</p>\n<h3 id=\"访问控制与继承\"><a href=\"#访问控制与继承\" class=\"headerlink\" title=\"访问控制与继承\"></a>访问控制与继承</h3><p>访问控制的继承遵循以下规则</p>\n<ul>\n<li>父类中声明为public的方法，在子类中必须声明为public</li>\n<li>父类中声明为protected的方法，在子类中声明为public或者protected</li>\n<li>父类中声明为private的方法，子类不可继承</li>\n</ul>\n","categories":["学习"],"tags":["Java"]}]