[{"title":"C++笔记: 类 (一)","url":"/2021/10/11/C-%E7%AC%94%E8%AE%B0-%E7%B1%BB-%E4%B8%80/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>​    C++是笔者这学期最重要的专业课之一。目前上课内容已简单介绍完C++的类的相关知识。</p>\n<p>​    但是由于老师上课时的解析<del>经常听不懂</del>比较有深度，目前我对于C++类的认识还比较浅显，所以打算再花点时间自学并整理一遍相关内容。</p>\n<p>​    <span id=\"more\"></span></p>\n<h2 id=\"类的声明及定义\"><a href=\"#类的声明及定义\" class=\"headerlink\" title=\"类的声明及定义\"></a>类的声明及定义</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>​    类即类型的简称，用于描述对象的共同属性和方法。在C++中，类可以使用 <code>struct</code> 、<code>class</code> 或者 <code>union</code> 来定义。其中，类的属性用数据成员表示，类的方法用函数成员来表示。类的成员可以使用保留字 <code>private</code> 、<code>public</code> 或者 <code>protected</code> 来标识访问权限。</p>\n<p>​    对象是类的实例，也就是某个类的值，它可以是一个变量，也可以是一个常量。类是一种__数据结构__，而对象代表了一段__内存__，存储了数据结构的值。当产生一个对象时，必须调用__构造函数__初始化对象；当一个对象“死亡”时，则需要调用__析构函数__释放对象占用的资源。</p>\n<h3 id=\"关于访问控制\"><a href=\"#关于访问控制\" class=\"headerlink\" title=\"关于访问控制\"></a>关于访问控制</h3><p>​    关键字<code>private</code> 、<code>public</code> 和 <code>protected</code>描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但<u>只能通过公有成员函数 (或者友元函数) 来访问对象的私有成员</u>。</p>\n<p>​    <code>private</code> 成员仅供<strong>同一类</strong>的成员函数访问；<code>protected</code> 成员仅供所在类及派生类的成员函数访问；<code>public</code> 成员可供任何成员或非成员函数访问。</p>\n<p>​    无论类的数据成员还是成员函数，都可以在类的公有部分或者私有部分中声明它。通常把数据成员放在私有部分，组成类接口的成员函数放在公有部分。</p>\n<p>​    不必在<strong>class类</strong>声明中使用关键字 <code>private</code> ，因为这是它的默认访问控制(注：struct和union定义的类成员默认访问权限为 <code>public</code>)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">world</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> mass;\t\t<span class=\"comment\">//默认是私有的</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[<span class=\"number\">20</span>]\t<span class=\"comment\">//私有</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>​    构造函数是类封装的特殊的实例函数成员，用于对对象的数据成员进行初始化，<u>对象必须初始化且仅能初始化一次</u>。 构造函数不能被显式调用。 </p>\n<p>​    构造函数为对象申请各种资源用于初始化。除了隐含参数 <code>this</code> 外，构造函数还可以自带若干参数。</p>\n<p>​    构造函数与类名同名。</p>\n<p>​    <strong>需要注意的是</strong>，如果没有提供任何构造函数，则C++会自动提供<strong>默认构造函数</strong>，它不会做任何工作。对于某个类，如Stock类，默认构造函数可能如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stock::<span class=\"built_in\">Stock</span>() &#123;...&#125;\t<span class=\"comment\">//参数表无参</span></span><br></pre></td></tr></table></figure>\n\n<p>​    并且，<strong>当且仅当</strong>没有定义任何构造函数时，编译器才会提供默认构造函数。也就是说，为类定义了构造函数之后，程序员还必须为类提供默认构造函数。如果在定义前者之后未定义后者，以下声明将出错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stock stock1;</span><br></pre></td></tr></table></figure>\n\n<p>​    通常用户定义的默认构造函数应可以给给所有成员提供隐式初始值。</p>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>​    析构函数也是类封装的特殊的实例函数成员，其特点是和类名同名且名前带有<strong>“ ~ ”</strong>，同时，无论是程序自定义还是C++默认生成的析构函数，都只能有一个隐含参数 <code>this</code> 。  析构函数可以被显式调用。</p>\n<p>​    析构函数用于对数据成员申请的资源进行回收，如果构造函数为类成员动态分配了内存（如<strong>new</strong>），则析构函数相应地要释放这些内存（<strong>delete</strong>）。与构造函数不同，析构函数可以执行多次，但是应当尽量避免资源被多次释放。</p>\n<p>​    构造函数和析构函数都不可以定义返回类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">STRING</span>\t\t\t\t//定义了一个名为<span class=\"title\">STRING</span>的类</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span>* CHARPTR;\t<span class=\"comment\">//定义类型成员</span></span><br><span class=\"line\">    CHARPTR s;\t\t\t\t<span class=\"comment\">//定义数据成员</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">strlen</span><span class=\"params\">()</span></span>;\t\t\t<span class=\"comment\">//定义函数成员</span></span><br><span class=\"line\">    <span class=\"built_in\">STRING</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>*);\t<span class=\"comment\">//定义构造函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">STRING</span>();\t\t\t\t<span class=\"comment\">//定义析构函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">STRING <span class=\"title\">y</span><span class=\"params\">(<span class=\"string\">&quot;complex&quot;</span>)</span></span>;\t<span class=\"comment\">//自动调用构造函数STRING(&quot;complex&quot;)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["学习"],"tags":["C++"]}]